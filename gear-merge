#!/bin/ash -efu
#
# Copyright (C) 2007  Alexey Gladkov <legion@altlinux.org>
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#
# Rules:
# directive: args
#
# directive             := ( merge | gendiff )
# args                  := ( strategy | squash | merge_specific_args | gendiff_specific_args )
# strategy              := <git merge strategy>
# gendiff_specific_args := ( name | unified )
# name                  := <file>
# unified               := <number>
#
# <git merge strategy> - Use the given merge strategy. See man git-merge(1).
#

. gear-sh-functions

main_tree_id='HEAD'
merge_rules='.gear/merge'

show_help() {
	cat <<EOF
$PROG - Merge branches in the package repository

Usage: $PROG [Options]

Options:

  -a, --add              add new patches in git repository;
  -r, --rules=FILENAME   name of file with rules, default is (default: $merge_rules);
  -v,--verbose           print a message for each action;
  -V,--version           print program version and exit;
  -h,--help              show this text and exit.

Report bugs to http://bugs.altlinux.ru/

EOF
	exit
}

print_version() {
	cat <<EOF
$PROG version $PROG_VERSION
Written by Alexey Gladkov <legion@altlinux.org>

Copyright (C) 2007  Alexey Gladkov <legion@altlinux.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
	exit
}

checkout_current=
current_branch=
workdir=
exit_handler() {
	local rc=$?
	trap - EXIT
	[ -z "$workdir" ] ||
		rm -rf -- "$workdir"

	if [ "$rc" -eq 0 -a -n "$checkout_current" ]; then
		git checkout "$current_branch"
	fi
	exit $rc
}

main_commit_id=
merge_rules=
find_merge_rules() {
	if [ -f "$workdir/rules" ]; then
		return 0
	elif [ -n "$(git ls-tree "$main_tree_id" "$merge_rules")" ]; then
		cat_blob "$main_tree_id" "$merge_rules" >"$workdir/rules"
	else
		: >"$workdir/rules"
	fi
}

is_already_merged() {
	local src dst missing
	src="$1"; shift
	dst="$1"; shift
	missing="$(git-rev-list --max-count=1 "$src".."$dst")"
	[ -z "$missing" ] || return 1
}

parse_common_options() {
	merge_squash=
	merge_strategy=

	[ "$#" -ne 0 ] ||
		return 0

	local o
	for o in "$@"; do
		case "$o" in
			merge_strategy=*) merge_strategy="${o#strategy=}" ;;
			merge_squash) merge_squash="--sq" ;;
		esac
	done
}

merge_branch() {
	local src dst
	src="$1"; shift
	dst="$1"; shift

	if is_already_merged "$src" "$dst"; then
		verbose "No new commits in branch '$src'."
		return 0
	fi

	parse_common_options "$@"

	git merge ${merge_squash:-} ${merge_strategy:+-s "$merge_strategy"} "refs/heads/$dst" ||
		fatal "Unable to merge \`$dst' automatically."
}

new_files=
add_new_files=
gendiff_branch() {
	local dir name= unified= o

	local src dst
	src="$1"; shift
	dst="$1"; shift

	git checkout "$dst"
	merge_branch "$dst" "$src" "$@"

	for o in "$@"; do
		case "$o" in
			name=*) name="${o#name=}" ;;
			unified=*) unified="${o#unified=}" ;;
		esac
	done

	[ -n "$name" ] ||
		fatal "Patch name not defined. Use 'name=' parameter."

	dir="${name%/*}"
	[ "$dir" = "$name" -o -d "$dir" ] ||
		mkdir -p -- "$dir"

	git diff -p ${unified:+-U"$unified"} "refs/heads/$src".."refs/heads/$dst" > "$name" ||
		fatal "Unable to generate diff between \`$src' and \`$dst'."

	[ -z "$add_new_files" ] ||
		new_files="$new_files $name"

	checkout_current=1
}

TEMP=`getopt -n $PROG -o a,r:,V,v,h -l add,rules:,version,verbose,help -- "$@"` || show_usage
eval set -- "$TEMP"

while :; do
	case "$1" in
		-a|--add) add_new_files=1
			;;
		-r|--rules) shift; merge_rules="$1"
			;;
		-v|--verbose) verbose=-v
			;;
		-V|--version) print_version
			;;
		-h|--help) show_help
			;;
		--) shift; break
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

# Save git directory for future use.
git_dir="$(git rev-parse --git-dir)"
git_dir="$(readlink -ev "$git_dir")"

# Change to toplevel directory.
chdir_to_toplevel

current_branch="$(git-symbolic-ref "$main_tree_id")"

[ -z "${current_branch%%refs/heads/*}" ] ||
	fatal "$main_tree_id: not a branch."

current_branch="${current_branch#refs/heads/}"

trap exit_handler HUP PIPE INT QUIT TERM EXIT
workdir="$(mktemp -dt "$PROG.XXXXXXXX")"

find_merge_rules

if [ ! -s "$workdir/rules" ]; then
	msg_info "No rules found."
	show_usage
	exit 0
fi

while read -r cmd options; do
	set -- $options

	cmd="${cmd%:}"
	case "$cmd" in
		merge)
			[ "$#" -ge 1 ] ||
				fatal "Bad \`$cmd' usage."

			src_branch="$current_branch"
			dst_branch="$1"; shift
			;;
		gendiff)
			[ "$#" -ge 2 ] ||
				fatal "Bad \`$cmd' usage."

			src_branch="$1"; shift
			dst_branch="$1"; shift
			;;
		""|\#*)
			continue
			;;
		*)
			fatal "Unknown command: $cmd"
			;;
	esac

	for b in "$src_branch" "$dst_branch"; do
		[ -n "$(git ls-remote -h . "refs/heads/$b")" ] ||
			fatal "$b: branch not found"
	done

	"${cmd}_branch" "$src_branch" "$dst_branch" "$@"

done < "$workdir/rules"

if [ -n "$add_new_files" -a -n "$new_files" ]; then
	git checkout "$current_branch"
	git add $new_files
	checkout_current=
fi
