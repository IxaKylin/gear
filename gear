#!/bin/sh -efu
#
# Copyright (C) 2006  Dmitry V. Levin <ldv@altlinux.org>
# Copyright (C) 2006  Sir Raorn <raorn@altlinux.org>
# Copyright (C) 2006  Alexey Gladkov <legion@altlinux.org>
# Copyright (C) 2006  Sergey Vlasov <vsu@altlinux.org>
#
# Get Every Archive from git package Repository.
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#

# Note about rules:
#  rules is plain text file, where each meaningful line has following format:
#  directive: args
#
#  Valid directives are:
#    spec, tags, copy, diff, diff.gz, diff.bz2, gzip, bzip2, exclude,
#    tar, tar.gz, tar.bz2, zip
#
#  Each directive has own args syntax:
#  spec: path_to_file
#  tags: path_to_directory
#  (copy|gzip|bzip2): glob_pattern..
#  (copy|gzip|bzip2)?: glob_pattern..
#  exclude: glob_pattern..
#  tar(|.gz|.bz2): tree_path [options]
#  tar(|.gz|.bz2)?: tree_path [options]
#  zip: tree_path [options]
#  zip?: tree_path [options]
#  diff(|.gz|.bz2): old_tree_path new_tree_path options
#  diff(|.gz|.bz2)?: old_tree_path new_tree_path options
#
#  tree_path may be a plain path or commit:path, where commit is specified
#  by tag name (keywords may be used) or full SHA-1.
#
#  Valid tar and zip options are:
#    name=archive_name  - archive name, may reference to keywords;
#    base=base_name     - when specified it is added as a leading path
#                         to the files in the generated tar archive.
#    spec=path_to_file  - path to specfile which defines keywords;
#  Valid tar keywords are:
#    @dir@ - basename(path(tree_path));
#    @name@, @version@, @release@.
#  Default tar archive name is @dir@-@version@.
#
#  Valid diff options are:
#    name=diff_name     - diff name, may reference to keywords;
#    spec=path_to_file  - path to specfile which defines keywords;
#  Valid diff keywords are:
#    @old_dir@ - basename(path(old_tree_path));
#    @new_dir@ - basename(path(new_tree_path));
#    @name@, @version@, @release@.
#  Default diff name is @new_dir@-@version@-@release@.patch.

. gear-sh-functions

print_version()
{
	cat <<EOF
$PROG version $PROG_VERSION
Written by Dmitry V. Levin <ldv@altlinux.org>

Copyright (C) 2006  Dmitry V. Levin <ldv@altlinux.org>
Copyright (C) 2006  Sir Raorn <raorn@altlinux.org>
Copyright (C) 2006  Alexey Gladkov <legion@altlinux.org>
Copyright (C) 2006  Sergey Vlasov <vsu@altlinux.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
	exit
}

show_help()
{
	cat <<EOF
$PROG - extract archive from git package repository.

Usage: $PROG [options] <output-tarball-name>
or:    $PROG [options] --export-dir=<dirname>
or:    $PROG [options] --hasher -- <hsh-command>...
or:    $PROG [options] --rpmbuild -- <rpmbuld-command>...

Options:
  --no-compress             do not compress output archive;
  --bzip2                   compress output archive using bzip2;
  --gzip                    compress output archive using gzip;
  --commit                  make temporary commit prior to extract;
  --hasher                  execute hsh-like command afterwards;
  --rpmbuild                execute rpmbuild-like command afterwards;
  --update-spec             change specfile in repository if specfile changed 
                            after --rpmbuild command;
  --export-dir=DIRNAME      write source files to specified directory;
  --describe                describe package as "%{NAME} %{VERSION} %{RELEASE}";
  -r, --rules=FILENAME      name of file with rules, default is .$PROG-rules;
  -t, --tree-ish=ID         COMMIT[:PATH] specifying the tree to process;
  -q, --quiet               try to be more quiet;
  -v, --verbose             print a message for each action;
  -V, --version             print program version and exit;
  -h, --help                show this text and exit.

Report bugs to http://bugs.altlinux.ru/

EOF
	exit
}

tmpdir=
need_git_reset=
exit_handler()
{
	local rc=$?
	trap - EXIT
	if [ -n "$need_git_reset" ]; then
		git-reset --soft HEAD^ &&
			verbose "Reverted temporary commit."
	fi
	[ -z "$tmpdir" ] ||
		rm -rf -- "$tmpdir"
	exit $rc
}

compress_file()
{
	local cmd="$1" && shift
	local file="$1" && shift

	case "$cmd" in
		gzip|*.gz)
			gzip -9 "$file"
			;;
		bzip2|*.bz2)
			bzip2 -9 "$file"
			;;
	esac
}

subst_NVR_from_spec()
{
	local spec="$1" && shift

	if [ -n "$spec" ]; then
		cat_blob "$main_tree_id" "$spec" >"$workdir/spec"
		spec="$workdir/spec"
	fi
	subst_NVR_from_spec_file "$spec" "$@"
}

get_tar_name()
{
	local dir_name_prefix="${dir_name%/*}"
	local dir_name_base="${dir_name##*/}"

	if [ "$dir_name" = "$dir_name_prefix" ]; then
		dir_name_prefix=
	else
		dir_name_prefix="$dir_name_prefix/"
	fi
	# "$dir_name" == "$dir_name_prefix$dir_name_base"

	local dir="$dir_name_base"
	[ "$dir" != . ] || dir=
	if [ -z "$dir" ]; then
		tar_name='@name@-@version@'
	else
		tar_name='@dir@-@version@'
	fi
	# Special non-empty marker.
	tar_base=' '

	local opt spec=

	for opt; do
		case "$opt" in
			spec=*) spec="${opt#spec=}"
				check_path specfile "$spec"
				;;
			name=*) tar_name="${opt#name=}"
				;;
			base=*) tar_base="${opt#base=}"
				;;
			*) rules_error "Unrecognized option: $opt"
				;;
		esac
	done

	local subst_vars="tar_name tar_tree"
	[ -z "$tar_base" -o "$tar_base" = ' ' ] ||
		subst_vars="$subst_vars tar_base"

	subst_NVR_from_spec "$spec" dir $subst_vars
	subst_key_in_vars '@dir@' "$dir" $subst_vars

	if [ -n "$dir" -a "$dir" != "$dir_name_base" ]; then
		check_name "dir name" "$dir"
		dir_name="$dir_name_prefix$dir"
	fi
	check_name "tar name" "$tar_name"
	[ -n "${subst_vars##*tar_base*}" ] ||
		check_name "tar base" "$tar_base"
}

make_tar()
{
	local format="$1" && shift
	local optional="$1" && shift
	local cmd="$1" && shift
	local tree="$1" && shift
	local dir="$1" && shift
	local name="$1" && shift
	tar_base="$1" && shift

	[ "$tar_base" != ' ' ] ||
		tar_base="$name"

	local id rc=0
	id="$(traverse_tree "$tree" "$dir" "$optional")" ||
		rc=$?
	if [ "$rc" = 1 ]; then exit 1
	elif [ "$rc" != 0 ]; then return 0
	fi

	git-archive --format="$format" ${tar_base:+--prefix="$tar_base"/} "$id" >"$outdir/$name.$format"
	verbose "Extracted \"$name.$format\" archive."
	compress_file "$cmd" "$outdir/$name.$format"
}

make_archive()
{
	# format: "format $optional cmd dirname options.."
	[ $# -ge 4 ] ||
		rules_error "No dirname specified"
	local format="$1" && shift
	local optional="$1" && shift
	local cmd="$1" && shift
	local tree_path="$1" && shift

	tree_path="$(parse_tree_path dirname "$tree_path")" || return 1
	local dir_name="${tree_path#*:}"
	tar_tree="${tree_path%%:*}"

	get_tar_name "$@"

	tar_tree="$(resolve_tree_base_name "$tar_tree")" || return 1
	make_tar "$format" "$optional" "$cmd" "$tar_tree" "$dir_name" "$tar_name" "$tar_base"
}

get_diff_name()
{
	local old_dir="$1" && shift
	local new_dir="$1" && shift

	[ "$old_dir" != '.' ] || old_dir=
	[ "$new_dir" != '.' ] || new_dir=

	if [ -z "$new_dir" ]; then
		diff_name='@name@-@version@-@release@.patch'
	else
		diff_name='@new_dir@-@version@-@release@.patch'
	fi

	local opt spec=

	for opt; do
		case "$opt" in
			spec=*) spec="${opt#spec=}"
				check_path specfile "$spec"
				;;
			name=*) diff_name="${opt#name=}"
				;;
			*) rules_error "Unrecognized option: $opt"
				;;
		esac
	done

	local subst_vars="diff_name diff_old_tree diff_new_tree"
	subst_key_in_vars '@old_dir@' "$old_dir" $subst_vars
	subst_key_in_vars '@new_dir@' "$new_dir" $subst_vars
	subst_NVR_from_spec "$spec" $subst_vars
}

make_diff()
{
	local optional="$1" && shift
	local cmd="$1" && shift
	local old_tree="$1" && shift
	local old_dir="$1" && shift
	local new_tree="$1" && shift
	local new_dir="$1" && shift
	local name="$1" && shift

	local old_id new_id rc

	rc=0
	old_id="$(traverse_tree "$old_tree" "$old_dir" "$optional")" ||
		rc=$?
	if [ "$rc" = 1 ]; then exit 1
	elif [ "$rc" != 0 ]; then return 0
	fi

	rc=0
	new_id="$(traverse_tree "$new_tree" "$new_dir" "$optional")" ||
		rc=$?
	if [ "$rc" = 1 ]; then exit 1
	elif [ "$rc" != 0 ]; then return 0
	fi

	git-diff-tree --patch-with-stat "$old_id" "$new_id" >"$outdir/$name"
	verbose "Extracted \"$name\" diff."
	compress_file "$cmd" "$outdir/$name"
}

make_difference()
{
	# format: "$optional cmd old_dir new_dir options.."
	[ $# -ge 4 ] ||
		rules_error "No old_dir or new_dir specified"
	local optional="$1" && shift
	local cmd="$1" && shift
	local old_dir="$1" && shift
	local new_dir="$1" && shift

	old_dir="$(parse_tree_path dirname "$old_dir")" ||
		rules_error "Invalid old_dir specified"
	diff_old_tree="${old_dir%%:*}"
	old_dir="${old_dir#*:}"

	new_dir="$(parse_tree_path dirname "$new_dir")" ||
		rules_error "Invalid new_dir specified"
	diff_new_tree="${new_dir%%:*}"
	new_dir="${new_dir#*:}"

	get_diff_name "$(basename -- "$old_dir")" "$(basename -- "$new_dir")" "$@"

	diff_old_tree="$(resolve_tree_base_name "$diff_old_tree")" ||
		rules_error "Invalid old tree"
	diff_new_tree="$(resolve_tree_base_name "$diff_new_tree")" ||
		rules_error "Invalid new tree"

	make_diff "$optional" "$cmd" "$diff_old_tree" "$old_dir" "$diff_new_tree" "$new_dir" "$diff_name"
}

copy_by_pattern()
{
	# format: "$optional cmd pattern.."
	[ $# -ge 3 ] ||
		rules_error "No pattern specified"
	local optional="$1" && shift
	local cmd="$1" && shift

	for pattern; do
		[ -z "$(printf %s "$pattern" |tr -d '[:alnum:]_.?*-/')" ] ||
			rules_error "Invalid copy pattern \"$pattern\" specified"
		local dir_name base_name rc=0
		dir_name="$(dirname "$pattern")"
		base_name="$(basename "$pattern")"
		tree="$(traverse_tree "$main_tree_id" "$dir_name" "$optional")" ||
			rc=$?
		if [ "$rc" = 1 ]; then exit 1
		elif [ "$rc" != 0 ]; then return 0
		fi
		git-ls-tree "$tree" >"$workdir/blobs"
		echo >>"$workdir/blobs"
		local mode otype id name found=
		while read -r mode otype id name; do
			# ignore non-blobs.
			[ "$otype" = blob ] ||
				continue
			# ignore invalid filenames.
			[ "$name" = "${name#*/}" -a \
			  "$name" = "${name%/*}" ] ||
				continue
			# ignore unmatched.
			[ -z "${name##$base_name}" -o \
			  -z "${name%%$base_name}" ] ||
				continue
			local ex_pattern sample
			sample="$dir_name/$name"
			for ex_pattern in $exclude_pattern_list; do
				# ignore excluded.
				[ -n "${sample##$ex_pattern}" -a \
				  -n "${sample%%$ex_pattern}" ] ||
				  	continue 2
			done
			git-cat-file blob "$id" >"$outdir/$name"
			verbose "Extracted \"$name\" by pattern \"$pattern\"."
			[ -n "${mode%%*7??}" ] ||
				chmod a+x "$outdir/$name"
			compress_file "$cmd" "$outdir/$name"
			found=1
		done <"$workdir/blobs"
		[ -n "$found" -o "$optional" = 1 ] ||
			rules_error "Unmatched pattern \"$pattern\" specified"
	done
}

parse_rules()
{
	[ -s "$workdir/rules" ] || return 0

	echo >>"$workdir/rules"

	exclude_pattern_list=
	lineno=0

	local cmd options
	while read -r cmd options; do
		lineno="$((lineno+1))"
		if [ "$cmd" = 'exclude:' ]; then
			[ -z "$(printf %s "$options" |tr -d '[:alnum:]_.?*-/')" ] ||
				rules_error "Invalid exclude pattern \"$options\" specified"
			exclude_pattern_list="$exclude_pattern_list $options"
		fi
	done <"$workdir/rules"

	lineno=0
	while read -r cmd options; do
		lineno="$((lineno+1))"
		local optional=0
		case "$cmd" in
			""|\#*)
				continue
				;;
			*\?:)
				cmd="${cmd%\?:}"
				optional=1
				;;
			*:)
				cmd="${cmd%:}"
				optional=0
				;;
			*)
				rules_info "Unrecognized rule ignored"
				continue
				;;
		esac
		case "$cmd" in
			spec|exclude|tags)
				continue
				;;
			tar|tar.gz|tar.bz2)
				make_archive "tar" "$optional" "$cmd" $options ||
					rules_error "Failed to make archive"
				;;
			zip)
				make_archive "zip" "$optional" "$cmd" $options ||
					rules_error "Failed to make archive"
				;;
			diff|diff.gz|diff.bz2)
				make_difference "$optional" "$cmd" $options ||
					rules_error "Failed to make diff"
				;;
			copy|gzip|bzip2)
				copy_by_pattern "$optional" "$cmd" $options ||
					rules_error "Failed to copy by pattern"
				;;
			*)
				rules_info "Unrecognized directive \"$cmd\" ignored"
				continue
				;;
		esac
	done <"$workdir/rules"
	lineno=
}

TEMP=`getopt -n $PROG -o r:,t:,h,q,v,V -l no-compress,commit,bzip2,gzip,hasher,rpmbuild,update-spec,export-dir:,describe,rules:,tree-ish:,help,quiet,verbose,version -- "$@"` ||
	show_usage
eval set -- "$TEMP"

hasher=
update_spec=
rpmbuild=
outdir=
describe=
do_commit=
rules=".$PROG-rules"
tag_dir_default=".$PROG-tags"
tar_compress=--gzip
main_tree_id=HEAD
while :; do
	case "$1" in
		--) shift; break
			;;
		--no-compress) tar_compress=
			;;
		--commit) do_commit=1
			[ "$main_tree_id" = HEAD ] ||
				show_usage 'Options --commit and --tree-ish are mutually exclusive.'
			;;
		--bzip2) tar_compress=--bzip2
			;;
		--gzip) tar_compress=--gzip
			;;
		--hasher) hasher=1
			[ -z "$outdir$rpmbuild$describe" ] ||
				show_usage 'Options --hasher, --rpmbuild, --export-dir and --describe are mutually exclusive.'
			;;
		--rpmbuild) rpmbuild=1
			[ -z "$hasher$outdir$describe" ] ||
				show_usage 'Options --hasher, --rpmbuild, --export-dir and --describe are mutually exclusive.'
			;;
		--update-spec) update_spec=1
			;;
		--export-dir)
			outdir="$(opt_check_dir "$1" "$2")"
			shift
			[ -z "$hasher$rpmbuild$describe" ] ||
				show_usage 'Options --hasher, --rpmbuild, --export-dir and --describe are mutually exclusive.'
			;;
		--describe) describe=1
			[ -z "$hasher$outdir$rpmbuild" ] ||
				show_usage 'Options --hasher, --rpmbuild, --export-dir and --describe are mutually exclusive.'
			;;
		-r|--rules) shift; rules="$1"
			;;
		-t|--tree-ish) shift; main_tree_id="$1"
			[ -z "$do_commit" -o "$main_tree_id" = HEAD ] ||
				show_usage 'Options --commit and --tree-ish are mutually exclusive.'
			;;
		-h|--help) show_help
			;;
		-q|--quiet) quiet=-q; verbose=
			;;
		-v|--verbose) verbose=-v; quiet=
			;;
		-V|--version) print_version
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

out_file=
if [ -n "$hasher" -o -n "$rpmbuild" ]; then
	# At least one argument, please.
	[ "$#" -ge 1 ] ||
		show_usage 'Not enough arguments.'
elif [ -n "$outdir" -o -n "$describe" ]; then
	[ "$#" -eq 0 ] ||
		show_usage 'Too many arguments.'
else
	# Exactly one argument, please.
	[ "$#" -ge 1 ] ||
		show_usage 'Not enough arguments.'
	[ "$#" -eq 1 ] ||
		show_usage 'Too many arguments.'
	out_file="$1"
	shift
fi

# Save git directory for future use.
git_dir="$(git-rev-parse --git-dir)"
git_dir="$(readlink -ev "$git_dir")"

# Check given tree-ish.
main_commit_id="${main_tree_id%%:*}"
main_commit_sha1="$(get_commit_sha1 "$main_commit_id")" ||
	fatal "Invalid commit \"$main_commit_id\""
main_tree_sha1="$(get_object_sha1 "$main_tree_id")" ||
	fatal "Invalid tree \"$main_tree_id\""
git-cat-file -e "$main_tree_sha1^{tree}" ||
	fatal "Invalid tree \"$main_tree_id\""

if [ -n "$update_spec" ]; then
	[ -n "$rpmbuild" -a -z "${GIT_DIR:-}" ] ||
		fatal "Unable to update specfile in this mode."
fi

tmpdir="$(mktemp -dt "$PROG.XXXXXXXX")"
trap exit_handler HUP PIPE INT QUIT TERM EXIT
workdir="$tmpdir/work"
mkdir "$workdir"
if [ -z "$outdir" ]; then
	outdir="$tmpdir/out"
	mkdir $verbose "$outdir"
fi

if [ -n "$do_commit" ]; then
	if git-commit -a -m "Temporary commit by $PROG."; then
		need_git_reset=1
		verbose "Temporarily committed local changes."
	fi
fi

find_specfile

if [ -n "$describe" ]; then
	printf "%s %s %s\n" "$pkg_name" "$pkg_version" "$pkg_release"
	exit 0
fi

# Create a temporary object directory for extracting stored tags.
orig_object_dir="${GIT_OBJECT_DIRECTORY-"$git_dir/objects"}"
mkdir -p "$tmpdir/objects/info"
printf %s\\n "$orig_object_dir" >"$tmpdir/objects/info/alternates"
GIT_OBJECT_DIRECTORY="$tmpdir/objects"
export GIT_OBJECT_DIRECTORY

find_tags
parse_rules

install -pm644 "$workdir/specfile" "$outdir/${specfile##*/}"
verbose "Extracted \"${specfile##*/}\" specfile."

if [ -n "$rpmbuild" ]; then
	run_command "$@" --define "_specdir $outdir" --define "_sourcedir $outdir" "$outdir/${specfile##*/}"
	if [ -n "$update_spec" ]; then
		cdup="$(git-rev-parse --show-cdup |tr -d '\n')"
		cmp -s "$outdir/${specfile##*/}" "$cdup$specfile" && rc=0 || rc="$?"
		[ "$rc" -ne 1 ] || cp $verbose -f -- "$outdir/${specfile##*/}" "$cdup$specfile"
	fi
else
	[ -z "$hasher" ] ||
		out_file="$workdir/pkg.tar"
	if [ -n "$out_file" ]; then
		find "$outdir" -maxdepth 1 -type f -printf '%f\0' |
			sort -uz |
			xargs -r0 tar --create --file="$out_file" --directory="$outdir" \
				--label="${specfile##*/}" --owner=root --group=root \
				--mode=u+w,go-w,go+rX $tar_compress --
		verbose "Created \"$out_file\" output tarball."
		if [ -n "$hasher" ]; then
			# Once tarball is created, its sources are no longer needed.
			rm -rf -- "$outdir"
			run_command "$@" "$out_file"
		fi
	fi
fi
