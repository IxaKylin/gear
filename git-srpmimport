#!/bin/sh -efu
#
# Copyright (C) 2006  Dmitry V. Levin <ldv@altlinux.org>
#
# Incrementally import source packages to git repository.
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#

PROG=git-srpmimport

info()
{
	printf %s\\n "$PROG: $*" >&2
}

fatal()
{
	printf %s\\n "$PROG: $*" >&2
	exit 1
}

quiet=
verbose=
verbose()
{
	[ -n "$verbose" ] || return 0
	info "$@"
}

print_version()
{
	cat <<EOF
$PROG version 0.2
Written by Dmitry V. Levin <ldv@altlinux.org>

Copyright (C) 2006  Dmitry V. Levin <ldv@altlinux.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
	exit
}

show_usage()
{
	[ -z "$*" ] || info "$*"
	echo "Try \`$PROG --help' for more information." >&2
	exit 1
}

show_help()
{
	cat <<EOF
$PROG - incrementally import source packages to git repository.

Usage: $PROG [options] <source-package>...
or:    $PROG [options] --stdin

Options:
  --branch=BRANCH           branch name where to import (default is "srpms");
  --import-only             do not perform a checkout after importing;
  --no-untar                do not unpack source tarballs;
  --stdin                   read source package names from stdin;
  -q, --quiet               try to be more quiet;
  -v, --verbose             print a message for each action;
  -V, --version             print program version and exit;
  -h, --help                show this text and exit.
    
Report bugs to http://bugs.altlinux.ru/

EOF
	exit
}

exit_handler()
{
	local rc=$?
	trap - EXIT
	cd "$saved_cwd"
	# Recover index file.
	if [ -z "$index_already_recovered" ]; then
		[ -f "$tmpdir/index" ] &&
			cp -p "$tmpdir/index" "$index_orig" ||
			rm -f "$index_orig" ||:
	fi
	rm -rf -- "$tmpdir"
	# Recover HEAD.
	[ "$branch_orig" = "refs/heads/$branch_import" ] ||
		git-symbolic-ref HEAD "$branch_orig"
	exit $rc
}

untar()
{
	local f="$1" tar_dir="$2" copy_dir="$3" base=
	shift 3

	[ -n "$no_untar" -o -n "${f%%*.tar}" ] ||
		base="$(tar -tf "$f" |sed -ne 's|^\([^/]\+\)/\?$|\1|p')"
	[ -n "$base" ] &&
		[ -z "$(printf %s "$base" |LC_COLLATE=C tr -d '[:alnum:]_.,+-')" ] ||
		base=
	if [ -n "$base" ]; then
		tar -xf "$f"
		rm "$f"
		local base_short
		base_short="$(printf %s "$base" |LC_COLLATE=C sed -e 's/-[0-9]\+[.[:alpha:]]\+[.[:alnum:]]*$//')"
		if [ -n "$base_short" -a "$base_short" != "$base" ] && [ ! -e "$base_short" ]; then
			mv "$base" "$base_short"
			base="$base_short"
		fi
		local tarball="${f%.tar}"
		if [ "$base" = "$tarball" ]; then
			printf '%s: %s\n' "$tar_dir" "$base" >>.gear-rules
		else
			printf '%s: %s base=%s\n' "$tar_dir" "$base" "$tarball" >>.gear-rules
		fi
		git-add $verbose .gear-rules "$base"
	else
		printf '%s: %s\n' "$copy_dir" "$f" >>.gear-rules
		git-add $verbose .gear-rules "$f"
	fi
}

import()
{
	local srpm="$1" && shift
	cd "$saved_cwd"
	verbose "Processing $srpm"
	srpm="$(readlink -ev "$srpm")"

	local header name version buildtime filelist author f spec
	header="$(od -A n -N 8 -t x1 -- "$srpm")" &&
	[ -n "$header" -a -z "${header## ed ab ee db ?? ?? 00 01}" ] &&
	name="$(rpmquery -p --qf '%{NAME}' -- "$srpm")" &&
	version="$(rpmquery -p --qf '%{VERSION}-%{RELEASE}' -- "$srpm")" &&
	buildtime="$(rpmquery -p --qf '%{BUILDTIME}' -- "$srpm")" &&
	filelist="$(rpm2cpio "$srpm" |cpio --list --quiet )" ||
		fatal "$srpm: Not a valid source rpm package"

	author="$(rpmquery -p --qf '%{CHANGELOGNAME}\n' -- "$srpm" |
		sed -ne 's/^\([^<]*<[^@]\+\(@\| at \)[^@]\+>\).*/\1/p' |
		sed -e s/alt-linux/altlinux/g)"

	# Use own directory for checkout.
	rm -rf "$workdir"
	mkdir "$workdir"
	cd "$workdir"
	rpm2cpio "$srpm" |cpio --extract $([ -n "$verbose" ] || echo --quiet)
	verbose "Unpacked ${srpm##*/}"

	rm -f "$index_orig"
	for f in $filelist; do
		case "$f" in
			*.tar)
				untar "$f" tar copy
				;;
			*.gz)
				gunzip "$f"
				untar "${f%.gz}" tar.gz gzip
				;;
			*.bz2)
				bunzip2 "$f"
				untar "${f%.bz2}" tar.bz2 bzip2
				;;
			*.spec)
				[ -z "$spec" ] ||
					info "${srpm##*/}: Too many spec files."
				spec="$f"
				git-add $verbose "$f"
				;;
			*)
				printf 'copy: %s\n' "$f" >>.gear-rules
				git-add $verbose .gear-rules "$f"
				;;
		esac
	done
	[ -n "$spec" ] ||
		info "${srpm##*/}: Spec file not found."

	TZ=UTC faketime -d "1970-01-01 $buildtime seconds" -- \
		git-commit -a -m "$version" ${author:+--author "$author"}
	verbose "Committed $name $version"
	TZ=UTC faketime -d "1970-01-01 $buildtime seconds" -- \
		git-tag -a -m "$name $version" "$version"
	info "Imported $srpm"
}

TEMP=`getopt -n $PROG -o h,q,v,V -l branch:,import-only,no-untar,stdin,help,quiet,verbose,version -- "$@"` ||
	show_usage
eval set -- "$TEMP"

branch_import=
import_only=
no_untar=
read_from_stdin=
while :; do
	case "$1" in
		--) shift; break
			;;
		--branch) shift; branch_import="$1"
			;;
		--import-only) import_only=1
			;;
		--no-untar) no_untar=1
			;;
		--stdin) read_from_stdin=1
			;;
		-h|--help) show_help
			;;
		-q|--quiet) quiet=-q; verbose=
			;;
		-v|--verbose) verbose=-v; quiet=
			;;
		-V|--version) print_version
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

if [ -n "$read_from_stdin" ]; then
	# No arguments, please.
	[ "$#" -eq 0 ] ||
		show_usage 'Too many arguments.'
else
	# At least one argument, please.
	[ "$#" -ge 1 ] ||
		show_usage 'Not enough arguments.'
fi

GIT_DIR="$(git-rev-parse --git-dir)"
GIT_DIR="$(readlink -ev "$GIT_DIR")"
export GIT_DIR

if [ -n "$branch_import" ]; then
	# Check given branch name
	[ -f "$GIT_DIR/refs/heads/$branch_import" ] ||
		fatal "$branch_import: branch not found"
else
	branch_import=srpms
fi

branch_orig="$(git-symbolic-ref HEAD)"
head_orig="$(git-rev-parse --verify HEAD 2>/dev/null ||:)"

unset GIT_INDEX_FILE ||:
index_orig="$GIT_DIR/index"
index_already_recovered=

# Save current work directory.
saved_cwd="$(/bin/pwd)"

tmpdir="$(mktemp -dt "$PROG.XXXXXXXX")"
trap exit_handler HUP PIPE INT QUIT TERM EXIT
workdir="$tmpdir/work"

# Backup index file.
[ ! -f "$index_orig" ] ||
	cp -p "$index_orig" "$tmpdir/index"

git-symbolic-ref HEAD "refs/heads/$branch_import"

if [ -n "$read_from_stdin" ]; then
	while read; do
		import "$REPLY"
	done
else
	for REPLY; do
		import "$REPLY"
	done
fi

# Merge after import.
cd "$saved_cwd"
head_new="$(git-rev-parse --verify HEAD 2>/dev/null ||:)"
if [ "$head_orig" = "$head_new" ]; then
	verbose "Nothing imported."
elif [ -z "$import_only" ]; then
	if [ -z "$head_orig" ]; then
		git-update-ref "$branch_orig" "refs/heads/$branch_import"
		info "Created ${branch_orig#refs/heads/} branch"
		git-symbolic-ref HEAD "$branch_orig"
		git-checkout -f
		index_already_recovered=1
	elif [ -n "$head_new" ]; then
		git-symbolic-ref HEAD "$branch_orig"
		git-checkout -f
		index_already_recovered=1
		git-merge srpmimport HEAD "$branch_import"
		info "Merged $branch_import branch into ${branch_orig#refs/heads/} branch"
	fi
fi
