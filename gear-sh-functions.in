#!/bin/sh -efu
#
# Copyright (C) 2006  Dmitry V. Levin <ldv@altlinux.org>
# Copyright (C) 2006  Alexey Gladkov <legion@altlinux.org>
# Copyright (C) 2006  Sergey Vlasov <vsu@altlinux.org>
#
# gear common shell functions.
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#

PROG="${0##*/}"
PROG_VERSION='@VERSION@'

info()
{
	printf %s\\n "$PROG: $*" >&2
}

fatal()
{
	printf %s\\n "$PROG: $*" >&2
	exit 1
}

quiet=
verbose=
verbose()
{
	[ -n "$verbose" ] || return 0
	info "$@"
}

show_usage()
{
	[ -z "$*" ] || info "$*"
	echo "Try \`$PROG --help' for more information." >&2
	exit 1
}

lineno=
rules=
rules_error()
{
	local lineno_text=
	[ -z "$lineno" ] || lineno_text=" line $lineno"
	fatal "$rules$lineno_text: $*"
}

rules_info()
{
	local lineno_text=
	[ -z "$lineno" ] || lineno_text=" line $lineno"
	info "$rules$lineno_text: $*"
}

# quote argument for sed regexp.
quote_sed_regexp()
{
	local out="$*"
	if [ -z "${out##*[\[\].^\$\\/]*}" ]; then
		out="$(printf %s "$out" |sed -e 's/[].^$[\/]/\\&/g')" ||
			return 1
	fi
	printf %s "$out"
}

# quote argument for shell.
quote_shell_arg()
{
	local out="$*"
	if [ -z "${out##*[\"\$\`\\]*}" ]; then
		out="$(printf %s "$out" |sed -e 's/["$`\]/\\&/g')" ||
			return 1
	fi
	printf %s "$out"
}

is_hex_sha1()
{
	[ "${#1}" -eq 40 ] || return 1

	# "${1##*[![:xdigit:]]*}" does not work in ash
	[ -n "${1##*[!0123456789abcdefABCDEF]*}" ] || return 1

	return 0
}

get_object_sha1()
{
	local name="$1" && shift

	local sha1
	sha1="$(git-rev-parse --verify "$name")" || return 1

	# Verify that we really got a SHA-1 (git-rev-parse --verify accepts
	# things like ^COMMIT and returns ^SHA1 for them).
	is_hex_sha1 "$sha1" || return 1

	printf %s "$sha1"
}

get_commit_sha1()
{
	local name="$1" && shift

	local sha1
	sha1="$(get_object_sha1 "$name")" || return 1
	git-rev-parse --verify "$sha1^0" || return 1
}

tree_entry_name()
{
	local tree="$1" && shift
	local path="$1" && shift

	if [ -z "${path#.}" ]; then
		printf %s "$tree"
	elif [ -z "${tree##*:*}" ]; then
		printf %s "$tree/$path"
	else
		printf %s "$tree:$path"
	fi
}

traverse_tree()
{
	local tree="$1" && shift
	local path="$1" && shift
	local optional="$1" && shift

	local id="$(tree_entry_name "$tree" "$path")"
	if git-cat-file tree "$id" >/dev/null 2>&1; then
		printf %s "$id"
	elif [ "$optional" = 1 ]; then
		return 2
	else
		rules_error "tree \"$path\" not found in \"$tree\""
	fi
}

# fetch blob by id+name.
cat_blob()
{
	local tree="$1" && shift
	local name="$1" && shift

	local id="$(tree_entry_name "$tree" "$name")"
	git-cat-file blob "$id" ||
		rules_error "blob \"$name\" not found in \"$tree\""
}

check_path()
{
	local name="$1" && shift
	local value="$1" && shift

	[ "$value" != '..' -a \
	  -n "${value##/*}" -a \
	  -n "${value##../*}" -a \
	  -n "${value%%*/..}" -a \
	  -n "${value##*/../*}" ] ||
		rules_error "Invalid $name \"$value\" specified"
}

check_name()
{
	local name="$1" && shift
	local value="$1" && shift

	[ -n "$value" ] ||
		rules_error "Empty $name \"$value\" specified"

	[ -z "$(printf %s "$value" |tr -d '[:alnum:]_.+-')" ] ||
		rules_error "Invalid $name \"$value\" specified"
}

workdir=
main_tree_id=
rules=
find_rules()
{
	if [ -f "$workdir/rules" ]; then
		return 0
	elif [ -n "$(git-ls-tree "$main_tree_id" "$rules")" ]; then
		cat_blob "$main_tree_id" "$rules" >"$workdir/rules"
	else
		: >"$workdir/rules"
	fi
}

get_filename_from_rules()
{
	local directive="$1" && shift
	local name="$1" && shift

	find_rules
	[ -s "$workdir/rules" ] || return 0

	local file="$(sed -ne "s/^$directive:[[:space:]]\\+\\([^[:space:]]\\+\\)/\\1/p" "$workdir/rules")"
	[ -n "$file" ] || return 0

	[ `printf %s "$file" |wc -l` -le 0 ] ||
		rules_error "More than one $name specified"
	check_path "$name" "$file"
	printf %s "$file"
}

spec_name=
spec_version=
spec_release=
get_NVR_from_spec()
{
	local spec="$1" && shift

	spec_name="$(sed '/^name:[[:space:]]*/I!d;s///;q' "$spec")"
	spec_version="$(sed '/^version:[[:space:]]*/I!d;s///;q' "$spec")"
	spec_release="$(sed '/^release:[[:space:]]*/I!d;s///;q' "$spec")"
}

specfile=
pkg_name=
pkg_version=
pkg_release=
find_specfile()
{
	# first try specfile defined in $rules if any.
	specfile="$(get_filename_from_rules spec specfile)"

	# second try specfile in toplevel tree.
	if [ -z "$specfile" ]; then
		specfile="$(git-ls-tree "$main_tree_id" |
			sed -ne 's/^[^[:space:]]\+[[:space:]]\+blob[[:space:]]\+[^[:space:]]\+[[:space:]]\+\([^/[:space:]]\+\.spec\)$/\1/p')"
		[ `printf %s "$specfile" |wc -l` -le 0 ] ||
			fatal "Too many specfiles found${GIT_DIR:+ in $GIT_DIR}"
	fi
	[ -n "$specfile" ] ||
		fatal "No specfiles found${GIT_DIR:+ in $GIT_DIR}"
	cat_blob "$main_tree_id" "$specfile" >"$workdir/specfile"

	local spec_name spec_version spec_release
	get_NVR_from_spec "$workdir/specfile"
	pkg_name="$spec_name"
	pkg_version="$spec_version"
	pkg_release="$spec_release"
}

tag_dir=
tag_dir_default=
find_tags()
{
	# first try tag directory defined in rules if any.
	tag_dir="$(get_filename_from_rules tags "tag directory")"

	# second try tag directory in toplevel tree.
	if [ -z "$tag_dir" ] && [ -n "$tag_dir_default" ]; then
		local id type
		id="$(tree_entry_name "$main_tree_id" "$tag_dir_default/list")"
		type="$(git-cat-file -t "$id" 2>/dev/null)" || type=
		if [ "$type" = "blob" ]; then
			tag_dir="$tag_dir_default"
		fi
	fi

	if [ -n "$tag_dir" ]; then
		cat_blob "$main_tree_id" "$tag_dir/list" >"$workdir/tags"
	else
		: >"$workdir/tags"
	fi
}

tag_list_lineno=
tag_list_error()
{
	local lineno_text=
	[ -z "$tag_list_lineno" ] || lineno_text=" line $tag_list_lineno"
	fatal "$tag_dir/list$lineno_text: $*"
}

lookup_tag()
{
	local tag_list_file="$1" && shift
	local requested_tag_name="$1" && shift
	local variable="$1" && shift

	local sha1 name
	tag_list_lineno=0
	while read -r sha1 name; do
		tag_list_lineno="$((tag_list_lineno+1))"
		if [ "$name" = "$requested_tag_name" ]; then
			eval "$variable=\"$(quote_shell_arg "$sha1")\""
			return 0
		fi
	done <"$tag_list_file"

	return 1
}

extract_stored_tag_chain()
{
	local sha1="$1" && shift

	local id type real_sha1 next
	id="$(tree_entry_name "$main_tree_id" "$tag_dir/$sha1")"
	type="$(git-cat-file -t "$id" 2>/dev/null)" || type=
	if [ "$type" = "blob" ]; then
		next="$(git-cat-file blob "$id" | sed -ne '1s/^object \(.*\)$/\1/p')" ||
			tag_list_error "Bad stored tag $sha1: parse failed"
		is_hex_sha1 "$next" ||
			tag_list_error "Bad stored tag $sha1: invalid format"
		real_sha1="$(git-cat-file blob "$id" | git-hash-object -t tag -w --stdin)" ||
			tag_list_error "Bad stored tag $sha1: extract failed"
		[ "$real_sha1" = "$sha1" ] ||
			tag_list_error "Bad stored tag $sha1: hash mismatch (got $real_sha1)"
		extract_stored_tag_chain "$next"
	elif [ -n "$type" ]; then
		tag_list_error "Bad stored tag $sha1: type=$type"
	else
		printf %s "$sha1"
	fi
}

def_spec_pattern='*.spec'
spec_pattern="$def_spec_pattern"
find_specfile_in_cwd()
{
	local prefix="$1" && shift

	local f pattern spec= many_specs=
	for pattern in ${spec_pattern}; do
		for f; do
			[ -z "${f##$pattern}" -o -z "${f%%$pattern}" ] ||
				continue
			[ ! -L "$f" -a -f "$f" ] ||
				continue
			[ -z "$spec" ] ||
				many_specs=1
			spec="$f"
		done
		[ -z "$spec" ] ||
			break
	done
	if [ -z "$spec" ]; then
		info "${prefix}Spec file not found."
	elif [ -n "$many_specs" ]; then
		info "${prefix}Too many spec files - ignored all."
		spec=
	fi

	if [ -n "$spec" ]; then
		printf %s "$spec"
		return 0
	else
		return 1
	fi
}

run_command()
{
	verbose "Executing: $*"
	"$@"
}

opt_check_dir()
{
	local value
	value="$(readlink -ev "$2")" &&
		[ -d "$value" -a -x "$value" ] ||
		fatal "$1: $2: Directory not available"
	printf %s "$value"
}
