#!/bin/sh -efu

. gear-sh-functions

. shell-error
. shell-args
. shell-getopt

show_help()
{
	cat <<-EOF
	Usage: $PROG [options] init
	   or: $PROG [options] update

	Options:
	  -f, --force        don't check untracked and modified files;
	  -v, --verbose      print a message for each action;
	  -V, --version      print program version and exit;
	  -h, --help         show this text and exit.

	Report bugs to http://bugzilla.altlinux.org/

	EOF
	exit
}

print_version()
{
	cat <<-EOF
	$PROG version $PROG_VERSION
	Written by Alexey Gladkov <legion@altlinux.org>

	Copyright (C) 2010  Alexey Gladkov <legion@altlinux.org>
	This is free software; see the source for copying conditions.  There is NO
	warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	EOF
	exit
}


submodule_remotes=
workdir=
cleanup_handler()
{
	if [ "${1-}" != 0 ]; then
		for s in $submodule_remotes; do
			git remote rm "$s"
		done
		[ -z "$submodule_remotes" ] ||
			git reset --hard HEAD
	fi
	[ ! -d "$workdir" ] ||
		rm -rf -- "$workdir"
}

TEMP=`getopt -n $PROG -o "f,h,v,V" -l "force,help,verbose,version" -- "$@"` ||
	show_usage
eval set -- "$TEMP"

force=
prefix=
while :; do
	case "$1" in
		-f|--force) force=1
			;;
		-h|--help) show_help
			;;
		-V|--version) print_version
			;;
		-v|--verbose) verbose=-v
			;;
		--) shift; break
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

[ "$#" -gt 0 ] ||
	show_usage 'Not enough arguments.'
[ "$#" -eq 1 ] ||
        show_usage 'Too many arguments.'

case "$1" in
	init|update)
		action="$1"; shift
		;;
	*)
		show_usage "Unrecognized action: $1"
		;;
esac


chdir_to_toplevel

if [ -z "$force" ]; then
	out="$(git diff-index --cached --name-only HEAD)"
	[ -z "$out" ] ||
		fatal 'Changed files found in the index.'

	out="$(git diff --name-only &&
	       git ls-files --directory --others --exclude-per-directory=.gitignore)"
	[ -z "$out" ] ||
		fatal 'Untracked or modified files found.'
fi

install_cleanup_handler cleanup_handler
workdir="$(mktemp -dt "$PROG.XXXXXXXXX")"

git cat-file blob HEAD:.gitmodules |
	sed -n 's/\[submodule "\([^"]\+\)"\].*/\1/p' > "$workdir/submodules"

[ -s "$workdir/submodules" ] ||
	fatal 'No submodules found in this repository.'

init()
{
	local branch name sha1 module_sha1

	git submodule init

	# Ensure that no remotes for submodules have been set up already.
	git remote > "$workdir/remotes"
	while read name; do
		while read remote; do
			[ "$name" != "$remote" ] ||
				fatal "$remote: remote already exists."
		done < "$workdir/remotes"
	done < "$workdir/submodules"

	branch="$(git symbolic-ref HEAD)"
	message "Using '$branch' to import submodules"

	while read name; do
		url="$(git config --get "submodule.$name.url")" ||
			fatal "$name: url not found"
		sha1="$(git submodule status -- "$name")" ||
			fatal "$name: submodule commit not found"

		message "Importing '$name' submodule from '$url'"
		submodule_remotes="$submodule_remotes $name"
		git remote add -f "$name" "$url"

		sha1="${sha1#+}"
		sha1="${sha1#-}"
		sha1="${sha1%% *}"
		module_sha1="$(get_commit_sha1 "$sha1")" ||
		        fatal "Invalid submodule commit 'sha1'"

		rm -rf -- "$name"/

		git merge -q -s ours --no-commit "$module_sha1"
		git read-tree --prefix="$name"/ -u "$module_sha1"

		git commit -m "Merge '$name' submodule from '$url' as our subtree"
	done < "$workdir/submodules"
}

update()
{
	local name

	while read name; do
		git remote $verbose update "$name"
		git merge -s subtree "remotes/$name/master"
	done < "$workdir/submodules"
}

$action
