#!/bin/sh -efu
#
# Copyright (C) 2006  Dmitry V. Levin <ldv@altlinux.org>
# 
# Get Every Archive from git package Repository.
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#

# Note about rules:
#  rules is plain text file, where each meaningful line has following format:
#  directive: args
#  
#  Valid directives are:
#  spec, copy, gzip, bzip2, tar, tar.gz, tar.bz2
#  
#  Each directive has own args syntax:
#  spec: path_to_file
#  (copy|gzip|bzip2): glob_pattern..
#  (copy|gzip|bzip2)?: glob_pattern..
#  tar(|.gz|.bz2): path_to_directory [options]
#  
#  Valid tar options are:
#    name=archive_name  - tar archive name, may reference to keywords;
#    base=base_name     - when specified it is added as a leading path
#                         to the files in the generated tar archive.
#    spec=path_to_file  - path to specfile which defines keywords;
#  Valid tar keywords are:
#    @dir@ - basename(path_to_directory);
#    @name@, @version@, @release@.
#  Default tar archive name is @dir@-@version@.

PROG=gear

info()
{
	printf %s\\n "$PROG: $*" >&2
}

fatal()
{
	printf %s\\n "$PROG: $*" >&2
	exit 1
}

quiet=
verbose=
verbose()
{
	[ -n "$verbose" ] || return 0
	info "$@"
}

lineno=
optional=
rules_error()
{
	local lineno_text=
	[ -z "$lineno" ] || lineno_text=" line $lineno"
	fatal "$rules$lineno_text: $*"
}

rules_info()
{
	local lineno_text=
	[ -z "$lineno" ] || lineno_text=" line $lineno"
	info "$rules$lineno_text: $*"
}

print_version()
{
	cat <<EOF
$PROG version 0.8
Written by Dmitry V. Levin <ldv@altlinux.org>

Copyright (C) 2006  Dmitry V. Levin <ldv@altlinux.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
	exit
}

show_usage()
{
	[ -z "$*" ] || info "$*"
	echo "Try \`$PROG --help' for more information." >&2
	exit 1
}

show_help()
{
	cat <<EOF
$PROG - extract archive from git package repository.

Usage: $PROG [options] <output-tarball-name>
or:    $PROG [options] --export-dir=<dirname>
or:    $PROG [options] --hasher -- <hsh-command>...
or:    $PROG [options] --rpmbuild -- <rpmbuld-command>...

Options:
  --no-compress             do not compress output archive;
  --bzip2                   compress output archive using bzip2;
  --gzip                    compress output archive using gzip;
  --hasher                  execute hsh-like command afterwards;
  --rpmbuild                execute rpmbuild-like command afterwards;
  --export-dir=DIRNAME      write source files to specified directory;
  -r, --rules=FILENAME      name of file with rules, default is .$PROG-rules;
  -t, --tree-ish=ID         tree, commit or tag object name;
  -q, --quiet               try to be more quiet;
  -v, --verbose             print a message for each action;
  -V, --version             print program version and exit;
  -h, --help                show this text and exit.
    
Report bugs to http://bugs.altlinux.ru/

EOF
	exit
}

tmpdir=
exit_handler()
{
	local rc=$?
	trap - EXIT
	[ -z "$tmpdir" ] || rm -rf -- "$tmpdir"
	exit $rc
}

# quote argument for sed regexp.
quote_sed_regexp()
{
	local out="$*"
	if [ -z "${out##*[\[\].^\$\\/]*}" ]; then
		out="$(printf %s "$out" |sed -e 's/[].^$[\/]/\\&/g')" || return 1
	fi
	printf %s "$out"
}

# quote argument for shell.
quote_shell_arg()
{
	local out="$*"
	if [ -z "${out##*[\"\$\`\\]*}" ]; then
		out="$(printf %s "$out" |sed -e 's/["$`\]/\\&/g')" || return 1
	fi
	printf %s "$out"
}

traverse_tree()
{
	tree="$1"
	shift

	local path="$1"
	shift

	set -- `printf %s "$path" |tr -s / ' '`
	local dir id quoted
	for dir; do
		[ "$dir" != . ] || continue
		quoted="$(quote_sed_regexp "$dir")"
		id="$(git-ls-tree "$tree" "$dir" |
			sed -ne 's/^[^[:space:]]\+[[:space:]]\+tree[[:space:]]\+\([^[:space:]]\+\)[[:space:]]\+'"$quoted"'$/\1/p')"
		if [ -z "$id" ]; then
			if [ "$optional" = 1 ]; then
				return 1
			else
				rules_error "tree $dir not found in $tree"
			fi
		fi
		tree="$id"
	done
}

# fetch blob by id+name.
cat_blob()
{
	tree="$1"
	shift

	local name dir_name base_name
	name="$1"
	shift

	dir_name="$(dirname -- "$name")"
	base_name="$(basename -- "$name")"

	local optional_saved="$optional"
	optional=0
	# modifies $tree
	traverse_tree "$tree" "$dir_name"
	optional="$optional_saved"

	# fetch blob from given tree.
	local blob quoted
	quoted="$(quote_sed_regexp "$base_name")"
	blob="$(git-ls-tree "$tree" "$base_name" |
		sed -ne 's/^[^[:space:]]\+[[:space:]]\+blob[[:space:]]\+\([^[:space:]]\+\)[[:space:]]\+'"$quoted"'$/\1/p')"

	[ -n "$blob" ] ||
		rules_error "blob $base_name not found in $tree"

	git-cat-file blob "$blob"
}

check_path()
{
	local name value
	name="$1" && shift
	value="$1" && shift

	[ "$value" != '..' -a \
	  -n "${value##/*}" -a \
	  -n "${value##../*}" -a \
	  -n "${value%%*/..}" -a \
	  -n "${value##*/../*}" ] ||
		rules_error "Invalid $name \"$value\" specified"
}

check_name()
{
	local name value
	name="$1" && shift
	value="$1" && shift

	[ -n "$value" ] ||
		rules_error "Empty $name \"$value\" specified"

	[ -z "$(printf %s "$value" |tr -d '[:alnum:]_.+-')" ] ||
		rules_error "Invalid $name \"$value\" specified"
}

find_specfile()
{
	specfile=
	# first try specfile defined in $rules if any.
	if [ -n "$(git-ls-tree "$tree_id" "$rules")" ]; then
		cat_blob "$tree_id" "$rules" >"$workdir/rules"
		# format: "spec: filename"
		specfile="$(sed -ne 's/^spec:[[:space:]]\+\([^[:space:]]\+\)/\1/p' "$workdir/rules")"
		[ `printf %s "$specfile" |wc -l` -le 1 ] ||
			rules_error "Too many specfiles specified"
		[ -z "$specfile" ] ||
			check_path specfile "$specfile"
	fi
	# second try specfile in toplevel tree.
	if [ -z "$specfile" ]; then
		specfile="$(git-ls-tree "$tree_id" |
			sed -ne 's/^[^[:space:]]\+[[:space:]]\+blob[[:space:]]\+[^[:space:]]\+[[:space:]]\+\([^/[:space:]]\+\.spec\)$/\1/p')"
		[ `printf %s "$specfile" |wc -l` -le 1 ] ||
			fatal "Too many specfiles found in $GIT_DIR"
	fi
	[ -n "$specfile" ] || fatal "No specfiles found in $GIT_DIR"
	cat_blob "$tree_id" "$specfile" >"$workdir/specfile"
	pkg_name="$(sed '/^name:[[:space:]]*/I!d;s///;q' "$workdir/specfile")"
	pkg_version="$(sed '/^version:[[:space:]]*/I!d;s///;q' "$workdir/specfile")"
	pkg_release="$(sed '/^release:[[:space:]]*/I!d;s///;q' "$workdir/specfile")"
}

subst_key()
{
	local var_name key_name key_value
	var_name="$1" && shift
	key_name="$1" && shift
	key_value="$1" && shift

	local quoted var_value
	eval "var_value=\"\$$var_name\""

	if [ "$var_value" != "${var_value#*$key_name*}" ]; then
		check_name "$key_name" "$key_value"
		quoted="$(quote_sed_regexp "$key_value")"
		var_value="$(printf %s "$var_value" |sed "s/$key_name/$quoted/g")"
	fi

	eval "$var_name=\"$(quote_shell_arg "$var_value")\""
}

subst_keywords()
{
	local var dir name version release
	var="$1" && shift
	dir="$1" && shift
	name="$1" && shift
	version="$1" && shift
	release="$1" && shift

	subst_key "$var" '@dir@' "$dir"
	subst_key "$var" '@name@' "$name"
	subst_key "$var" '@version@' "$version"
	subst_key "$var" '@release@' "$release"

	eval check_name "$var" "\"\$$var\""
}

get_tar_name()
{
	local dir="$1"
	shift
	if [ "$dir" = . ]; then
		dir=
		tar_name='@name@-@version@'
	else
		tar_name='@dir@-@version@'
	fi
	tar_base=

	local opt quoted spec= spec_name= spec_version= spec_release=

	for opt; do
		case "$opt" in
			spec=*) spec="${opt#spec=}"
				check_path specfile "$spec"
				;;
			name=*) tar_name="${opt#name=}"
				;;
			base=*) tar_base="${opt#base=}"
				;;
			*) rules_error "Unrecognized option: $opt"
				;;
		esac
	done

	if [ -n "$spec" ]; then
		cat_blob "$tree_id" "$spec" >"$workdir/spec"
		spec_name="$(sed '/^name:[[:space:]]*/I!d;s///;q' "$workdir/spec")"
		spec_version="$(sed '/^version:[[:space:]]*/I!d;s///;q' "$workdir/spec")"
		spec_release="$(sed '/^release:[[:space:]]*/I!d;s///;q' "$workdir/spec")"
	fi
	[ -n "$spec_name" ] || spec_name="$pkg_name"
	[ -n "$spec_version" ] || spec_version="$pkg_version"
	[ -n "$spec_release" ] || spec_release="$pkg_release"

	subst_keywords tar_name "$dir" "$spec_name" "$spec_version" "$spec_release"
	[ -z "$tar_base" ] ||
		subst_keywords tar_base "$dir" "$spec_name" "$spec_version" "$spec_release"
}

make_tar()
{
	local cmd dir name
	cmd="$1"
	shift
	dir="$1"
	shift
	name="$1"
	shift
	tar_base="$1"
	shift
	[ -n "$tar_base" ] ||
		tar_base="$name"

	local id
	if [ "$dir" = . ]; then
		id="$tree_id"
	else
		local dir_name base_name quoted
		dir_name="$(dirname -- "$dir")"
		base_name="$(basename -- "$dir")"
		# modifies $tree
		traverse_tree "$tree_id" "$dir_name" ||
			return 0
		quoted="$(quote_sed_regexp "$base_name")"
		id="$(git-ls-tree "$tree" "$base_name" |
			sed -ne 's/^[^[:space:]]\+[[:space:]]\+tree[[:space:]]\+\([^[:space:]]\+\)[[:space:]]\+'"$quoted"'$/\1/p')"
		if [ -z "$id" ]; then
			if [ "$optional" = 1 ]; then
				return 0
			else
				rules_error "tree $dir not found in $tree"
			fi
		fi

	fi

	git-tar-tree "$id" "$tar_base" >"$outdir/$name.tar"
	verbose "Extracted \"$name.tar\" tarball."
	case "$cmd" in
		tar.gz)
			gzip -9 "$outdir/$name.tar"
			;;
		tar.bz2)
			bzip2 -9 "$outdir/$name.tar"
			;;
	esac
}

make_archive()
{
	# format: "cmd dirname options.."
	local cmd="$1" dir_name="$2"
	[ -n "$dir_name" ] ||
		rules_error "No dirname specified"
	shift 2
	check_path dirname "$dir_name"

	get_tar_name "$(basename -- "$dir_name")" "$@"
	make_tar "$cmd" "$dir_name" "$tar_name" "$tar_base"
}

copy_by_pattern()
{
	# format: "cmd pattern.."
	[ $# -ge 2 ] ||
		rules_error "No pattern specified"
	local cmd="$1"
	shift

	for pattern; do
		[ -z "$(printf %s "$pattern" |tr -d '[:alnum:]_.?*-/')" ] ||
			rules_error "Invalid pattern \"$pattern\" specified"
		local dir_name base_name
		dir_name="$(dirname "$pattern")"
		base_name="$(basename "$pattern")"
		# modifies $tree
		traverse_tree "$tree_id" "$dir_name" ||
			return 0
		git-ls-tree "$tree" >"$workdir/blobs"
		echo >>"$workdir/blobs"
		local mode otype id name found=
		while read -r mode otype id name; do
			[ "$otype" = blob ] || continue
			[ "$name" = "${name#*/}" -a "$name" = "${name%/*}" ] || continue
			[ -z "${name##$base_name}" -o -z "${name%%$base_name}" ] || continue
			git-cat-file blob "$id" >"$outdir/$name"
			verbose "Extracted \"$name\" by pattern \"$pattern\"."
			[ -n "${mode%%*7??}" ] ||
				chmod a+x "$outdir/$name"
			case "$cmd" in
				gzip)
					gzip -9 "$outdir/$name"
					;;
				bzip2)
					bzip2 -9 "$outdir/$name"
					;;
			esac
			found=1
		done <"$workdir/blobs"
		[ -n "$found" -o "$optional" = 1 ] ||
			rules_error "Unmatched pattern \"$pattern\" specified"
	done
}

parse_rules()
{
	[ -s "$workdir/rules" ] || return 0

	lineno=0
	local cmd options
	echo >>"$workdir/rules"
	while read -r cmd options; do
		lineno="$((lineno+1))"
		optional=0
		case "$cmd" in
			""|\#*)
				continue
				;;
			*\?:)
				cmd="${cmd%\?:}"
				optional=1
				;;
			*:)
				cmd="${cmd%:}"
				optional=0
				;;
			*)
				rules_info "Unrecognized rule ignored"
				continue
				;;
		esac
		case "$cmd" in
			spec)
				continue
				;;
			tar|tar.gz|tar.bz2)
				make_archive "$cmd" $options ||
					rules_error "Failed to make archive"
				;;
			copy|gzip|bzip2)
				copy_by_pattern "$cmd" $options ||
					rules_error "Failed to copy by pattern"
				;;
			*)
				rules_info "Unrecognized directive \"$cmd\" ignored"
				continue
				;;
		esac
	done <"$workdir/rules"
	lineno=
}

run_command()
{
	verbose "Executing: $*"
	"$@"
}

opt_check_dir()
{
	local value
	value="$(readlink -ev "$2")" &&
		[ -d "$value" -a -x "$value" ] ||
		fatal "$1: $2: Directory not available"
	printf %s "$value"
}

TEMP=`getopt -n $PROG -o r:,t:,h,q,v,V -l no-compress,bzip2,gzip,hasher,rpmbuild,export-dir:,rules:,tree-ish:,help,quiet,verbose,version -- "$@"` ||
	show_usage
eval set -- "$TEMP"

hasher=
rpmbuild=
outdir=
rules=".$PROG-rules"
tar_compress=--gzip
tree_id=HEAD
while :; do
	case "$1" in
		--) shift; break
			;;
		--no-compress) tar_compress=
			;;
		--bzip2) tar_compress=--bzip2
			;;
		--gzip) tar_compress=--gzip
			;;
		--hasher) hasher=1
			[ -z "$outdir$rpmbuild" ] ||
				show_usage 'Options --hasher, --rpmbuild and --export-dir are mutually exclusive.'
			;;
		--rpmbuild) rpmbuild=1
			[ -z "$hasher$outdir" ] ||
				show_usage 'Options --hasher, --rpmbuild and --export-dir are mutually exclusive.'
			;;
		--export-dir)
			outdir="$(opt_check_dir "$1" "$2")"
			shift
			[ -z "$hasher$rpmbuild" ] ||
				show_usage 'Options --hasher, --rpmbuild and --export-dir are mutually exclusive.'
			;;
		-r|--rules) shift; rules="$1"
			;;
		-t|--tree-ish) shift; tree_id="$1"
			;;
		-h|--help) show_help
			;;
		-q|--quiet) quiet=-q; verbose=
			;;
		-v|--verbose) verbose=-v; quiet=
			;;
		-V|--version) print_version
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

out_file=
if [ -n "$hasher" -o -n "$rpmbuild" ]; then
	# At least one argument, please.
	[ "$#" -ge 1 ] ||
		show_usage 'Not enough arguments.'
elif [ -n "$outdir" ]; then
	[ "$#" -eq 0 ] ||
		show_usage 'Too many arguments.'
else
	# Exactly one argument, please.
	[ "$#" -ge 1 ] ||
		show_usage 'Not enough arguments.'
	[ "$#" -eq 1 ] ||
		show_usage 'Too many arguments.'
	out_file="$1"
	shift
fi

# Check given tree-ish.
type="$(git-cat-file -t "$tree_id")" ||
	fatal "Invalid GIT_DIR ($GIT_DIR) or tree-ish ($tree_id)"
case "$type" in
	tag|commit|tree)
		;;
	*)
		fatal "Invalid tree-ish type: $type"
		;;
esac

tmpdir="$(mktemp -dt "$PROG.XXXXXXXX")"
trap exit_handler HUP PIPE INT QUIT TERM EXIT
workdir="$tmpdir/work"
mkdir "$workdir"
if [ -z "$outdir" ]; then
	outdir="$tmpdir/out"
	mkdir $verbose "$outdir"
fi

find_specfile

parse_rules

install -pm644 "$workdir/specfile" "$outdir/${specfile##*/}"
verbose "Extracted \"${specfile##*/}\" specfile."

if [ -n "$rpmbuild" ]; then
	run_command "$@" --define "_specdir $outdir" --define "_sourcedir $outdir" "$outdir/${specfile##*/}"
else
	[ -z "$hasher" ] ||
		out_file="$workdir/pkg.tar"
	if [ -n "$out_file" ]; then
		find "$outdir" -maxdepth 1 -type f -printf '%f\0' |
			sort -uz |
			xargs -r0 tar --create --file="$out_file" --directory="$outdir" \
				--label="${specfile##*/}" --owner=root --group=root \
				--mode=u+w,go-w,go+rX $tar_compress --
		verbose "Created \"$out_file\" output tarball."
		if [ -n "$hasher" ]; then
			# Once tarball is created, its sources are no longer needed.
			rm -rf -- "$outdir"
			run_command "$@" "$out_file"
		fi
	fi
fi
