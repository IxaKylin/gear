#!/bin/sh -efu
#
# Copyright (C) 2006-2008  Dmitry V. Levin <ldv@altlinux.org>
# Copyright (C) 2006  Sir Raorn <raorn@altlinux.org>
# Copyright (C) 2006-2008  Alexey Gladkov <legion@altlinux.org>
# Copyright (C) 2006  Sergey Vlasov <vsu@altlinux.org>
# Copyright (C) 2006  Fr. Br. George <george@altlinux.org>
#
# Get Every Archive from git package Repository.
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#

# Note about rules:
#  rules is plain text file, where each meaningful line has following format:
#  directive: args
#
#  Valid directives are:
#    spec, tags, copy, diff, diff.gz, diff.bz2, gzip, bzip2, exclude,
#    tar, tar.gz, tar.bz2, zip
#
#  Each directive has own args syntax:
#  spec: path_to_file
#  tags: path_to_directory
#  (copy|gzip|bzip2): glob_pattern..
#  (copy|gzip|bzip2)?: glob_pattern..
#  exclude: glob_pattern..
#  tar(|.gz|.bz2): tree_path [options]
#  tar(|.gz|.bz2)?: tree_path [options]
#  zip: tree_path [options]
#  zip?: tree_path [options]
#  diff(|.gz|.bz2): old_tree_path new_tree_path options
#  diff(|.gz|.bz2)?: old_tree_path new_tree_path options
#
#  tree_path may be a plain path or commit:path, where commit is specified
#  by tag name (keywords may be used) or full SHA-1.
#
#  Valid tar and zip options are:
#    name=archive_name  - archive name, may reference to keywords;
#    base=base_name     - when specified it is added as a leading path
#                         to the files in the generated tar archive;
#    spec=path_to_file  - path to specfile which defines keywords;
#    suffix=suffix      - override default output file name suffix.
#  Valid tar keywords are:
#    @dir@ - basename(path(tree_path));
#    @name@, @version@, @release@.
#  Default tar archive name is @dir@-@version@.
#
#  Valid diff options are:
#    name=diff_name     - diff name, may reference to keywords;
#    spec=path_to_file  - path to specfile which defines keywords.
#  Valid diff keywords are:
#    @old_dir@ - basename(path(old_tree_path));
#    @new_dir@ - basename(path(new_tree_path));
#    @name@, @version@, @release@.
#  Default diff name is @new_dir@-@version@-@release@.patch.

. gear-sh-functions
. shell-getopt

print_version()
{
	cat <<EOF
$PROG version $PROG_VERSION
Written by Dmitry V. Levin <ldv@altlinux.org>

Copyright (C) 2006-2008  Dmitry V. Levin <ldv@altlinux.org>
Copyright (C) 2006  Sir Raorn <raorn@altlinux.org>
Copyright (C) 2006-2008  Alexey Gladkov <legion@altlinux.org>
Copyright (C) 2006  Sergey Vlasov <vsu@altlinux.org>
Copyright (C) 2006  Fr. Br. George <george@altlinux.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
	exit
}

show_help()
{
	cat <<EOF
$PROG - extract archive from git package repository.

Usage: $PROG [options] <output-tarball-name>
or:    $PROG [options] --export-dir=<dirname>
or:    $PROG [options] --command -- <command>...
or:    $PROG [options] --hasher -- <hsh-command>...
or:    $PROG [options] --rpmbuild -- <rpmbuld-command>...

Options:
  --no-compress             do not compress output archive;
  --bzip2                   compress output archive using bzip2;
  --gzip                    compress output archive using gzip;
  --commit                  make temporary commit prior to extract;
  --command                 execute arbitrary command afterwards;
  --hasher                  execute hsh-like command afterwards;
  --rpmbuild                execute rpmbuild-like command afterwards;
  --update-spec             if specfile was changed after executed rpmbuild
                            command, then update it in the git repository;
  --export-dir=DIRNAME      write source files to specified directory;
  --describe                describe package as "%{NAME} %{VERSION} %{RELEASE}";
  -r, --rules=FILENAME      override rules file name;
  -t, --tree-ish=ID         COMMIT[:PATH] specifying the tree to process;
  -q, --quiet               try to be more quiet;
  -v, --verbose             print a message for each action;
  -V, --version             print program version and exit;
  -h, --help                show this text and exit.

Report bugs to http://bugzilla.altlinux.org/

EOF
	exit
}

tmpdir=
tmp_commit_id=
exit_handler()
{
	local rc=$?
	trap - EXIT
	if [ -n "$tmp_commit_id" ]; then
		if [ "$(get_object_sha1 HEAD)" = "$tmp_commit_id" ] &&
		   git reset --soft HEAD^; then
			verbose "Reverted temporary commit $tmp_commit_id."
		else
			msg_info "Failed to revert temporary commit $tmp_commit_id."
		fi
	fi
	[ -z "$tmpdir" ] ||
		rm -rf -- "$tmpdir"
	exit $rc
}

compress_file()
{
	local cmd="$1" && shift
	local file="$1" && shift

	case "$cmd" in
		gzip|*.gz)
			gzip -9 "$file"
			printf '%s' "$file.gz"
			;;
		bzip2|*.bz2)
			bzip2 -9 "$file"
			printf '%s' "$file.bz2"
			;;
		*)
			printf '%s' "$file"
			;;
	esac
}

subst_NVR_from_spec()
{
	local spec="$1" && shift

	if [ -n "$spec" ]; then
		cat_blob "$main_tree_id" "$spec" >"$workdir/spec"
		spec="$workdir/spec"
	fi
	subst_NVR_from_spec_file "$spec" "$@"
}

get_tar_name()
{
	local dir_name_prefix="${dir_name%/*}"
	local dir_name_base="${dir_name##*/}"

	if [ "$dir_name" = "$dir_name_prefix" ]; then
		dir_name_prefix=
	else
		dir_name_prefix="$dir_name_prefix/"
	fi
	# "$dir_name" == "$dir_name_prefix$dir_name_base"

	local dir="$dir_name_base"
	[ "$dir" != . ] || dir=
	if [ -z "$dir" ]; then
		tar_name='@name@-@version@'
	else
		tar_name='@dir@-@version@'
	fi
	# Special non-empty marker.
	tar_base=' '

	local opt spec=

	for opt; do
		case "$opt" in
			spec=*) spec="${opt#spec=}"
				check_path specfile "$spec"
				;;
			name=*) tar_name="${opt#name=}"
				;;
			base=*) tar_base="${opt#base=}"
				;;
			suffix=*) tar_suffix="${opt#suffix=}"
				;;
			*) rules_error "Unrecognized option: $opt"
				;;
		esac
	done

	local subst_vars='tar_name tar_tree'
	[ -z "$tar_base" -o "$tar_base" = ' ' ] ||
		subst_vars="$subst_vars tar_base"

	subst_NVR_from_spec "$spec" dir $subst_vars
	subst_key_in_vars '@dir@' "$dir" $subst_vars

	if [ -n "$dir" -a "$dir" != "$dir_name_base" ]; then
		check_name 'dir name' "$dir"
		dir_name="$dir_name_prefix$dir"
	fi
	check_name 'tar name' "$tar_name"
	[ -n "${subst_vars##*tar_base*}" ] ||
		check_name 'tar base' "$tar_base"
}

make_tar()
{
	local format="$1" && shift
	local optional="$1" && shift
	local cmd="$1" && shift
	local tree="$1" && shift
	local dir="$1" && shift
	local name="$1" && shift
	tar_base="$1" && shift
	local suffix="$1" && shift

	[ "$tar_base" != ' ' ] ||
		tar_base="$name"

	local id rc=0
	id="$(traverse_tree "$tree" "$dir" "$optional")" ||
		rc=$?
	if [ "$rc" = 1 ]; then exit 1
	elif [ "$rc" != 0 ]; then return 0
	fi

	git archive --format="$format" ${tar_base:+--prefix="$tar_base"/} "$id" >"$outdir/$name.$format"
	local archive_name
	archive_name="$(compress_file "$cmd" "$outdir/$name.$format")"
	if [ -n "$suffix" -a "$archive_name" != "$outdir/$name$suffix" ]; then
		mv "$archive_name" "$outdir/$name$suffix"
		archive_name="$outdir/$name$suffix"
	fi
	verbose "Extracted archive: ${archive_name##*/}"
}

make_archive()
{
	# format: "format $optional cmd dirname options.."
	[ $# -ge 4 ] ||
		rules_error 'No dirname specified'
	local format="$1" && shift
	local optional="$1" && shift
	local cmd="$1" && shift
	local tree_path="$1" && shift

	tree_path="$(parse_tree_path dirname "$tree_path")" || return 1
	local dir_name="${tree_path#*:}"
	tar_tree="${tree_path%%:*}"

	local tar_suffix=
	get_tar_name "$@"

	tar_tree="$(resolve_tree_base_name "$tar_tree")" || return 1
	make_tar "$format" "$optional" "$cmd" "$tar_tree" "$dir_name" "$tar_name" "$tar_base" "$tar_suffix"
}

get_diff_name()
{
	local old_dir="$1" && shift
	local new_dir="$1" && shift

	[ "$old_dir" != '.' ] || old_dir=
	[ "$new_dir" != '.' ] || new_dir=

	if [ -z "$new_dir" ]; then
		diff_name='@name@-@version@-@release@.patch'
	else
		diff_name='@new_dir@-@version@-@release@.patch'
	fi

	local opt spec=

	for opt; do
		case "$opt" in
			spec=*) spec="${opt#spec=}"
				check_path specfile "$spec"
				;;
			name=*) diff_name="${opt#name=}"
				;;
			*) rules_error "Unrecognized option: $opt"
				;;
		esac
	done

	local subst_vars='diff_name diff_old_tree diff_new_tree'
	subst_key_in_vars '@old_dir@' "$old_dir" $subst_vars
	subst_key_in_vars '@new_dir@' "$new_dir" $subst_vars
	subst_NVR_from_spec "$spec" $subst_vars
}

make_diff()
{
	local optional="$1" && shift
	local cmd="$1" && shift
	local old_tree="$1" && shift
	local old_dir="$1" && shift
	local new_tree="$1" && shift
	local new_dir="$1" && shift
	local name="$1" && shift

	local old_id new_id rc

	rc=0
	old_id="$(traverse_tree "$old_tree" "$old_dir" "$optional")" ||
		rc=$?
	if [ "$rc" = 1 ]; then exit 1
	elif [ "$rc" != 0 ]; then return 0
	fi

	rc=0
	new_id="$(traverse_tree "$new_tree" "$new_dir" "$optional")" ||
		rc=$?
	if [ "$rc" = 1 ]; then exit 1
	elif [ "$rc" != 0 ]; then return 0
	fi

	git diff-tree --patch-with-stat --text --no-renames --no-ext-diff \
		"$old_id" "$new_id" >"$outdir/$name"
	verbose "Extracted diff: $name"
	compress_file "$cmd" "$outdir/$name" > /dev/null
}

make_difference()
{
	# format: "$optional cmd old_dir new_dir options.."
	[ $# -ge 4 ] ||
		rules_error 'No old_dir or new_dir specified'
	local optional="$1" && shift
	local cmd="$1" && shift
	local old_dir="$1" && shift
	local new_dir="$1" && shift

	old_dir="$(parse_tree_path dirname "$old_dir")" ||
		rules_error "Invalid old_dir specified: $old_dir"
	diff_old_tree="${old_dir%%:*}"
	old_dir="${old_dir#*:}"

	new_dir="$(parse_tree_path dirname "$new_dir")" ||
		rules_error "Invalid new_dir specified: $new_dir"
	diff_new_tree="${new_dir%%:*}"
	new_dir="${new_dir#*:}"

	get_diff_name "$(basename -- "$old_dir")" "$(basename -- "$new_dir")" "$@"

	diff_old_tree="$(resolve_tree_base_name "$diff_old_tree")" ||
		rules_error "Invalid old tree: $diff_old_tree"
	diff_new_tree="$(resolve_tree_base_name "$diff_new_tree")" ||
		rules_error "Invalid new tree: $diff_new_tree"

	make_diff "$optional" "$cmd" "$diff_old_tree" "$old_dir" "$diff_new_tree" "$new_dir" "$diff_name"
}

copy_by_pattern()
{
	# format: "$optional cmd pattern.."
	[ $# -ge 3 ] ||
		rules_error 'No pattern specified'
	local optional="$1" && shift
	local cmd="$1" && shift

	for pattern; do
		[ -z "$(printf %s "$pattern" |tr -d '[:alnum:]_.?*-/')" ] ||
			rules_error "Invalid copy pattern specified: $pattern"
		local dir_name base_name rc=0
		dir_name="$(dirname "$pattern")"
		base_name="$(basename "$pattern")"
		tree="$(traverse_tree "$main_tree_id" "$dir_name" "$optional")" ||
			rc=$?
		if [ "$rc" = 1 ]; then exit 1
		elif [ "$rc" != 0 ]; then return 0
		fi
		git ls-tree "$tree" >"$workdir/blobs"
		echo >>"$workdir/blobs"
		local mode otype id name found=
		while read -r mode otype id name; do
			# ignore non-blobs.
			[ "$otype" = blob ] ||
				continue
			# ignore invalid filenames.
			[ "$name" = "${name#*/}" -a \
			  "$name" = "${name%/*}" ] ||
				continue
			# ignore unmatched.
			[ -z "${name##$base_name}" -o \
			  -z "${name%%$base_name}" ] ||
				continue
			local ex_pattern sample
			sample="$dir_name/$name"
			for ex_pattern in $exclude_pattern_list; do
				# ignore excluded.
				[ -n "${sample##$ex_pattern}" -a \
				  -n "${sample%%$ex_pattern}" ] ||
				  	continue 2
			done
			git cat-file blob "$id" >"$outdir/$name"
			verbose "Extracted file by pattern \"$pattern\": $name"
			[ -n "${mode%%*7??}" ] ||
				chmod a+x "$outdir/$name"
			compress_file "$cmd" "$outdir/$name" > /dev/null
			found=1
		done <"$workdir/blobs"
		[ -n "$found" -o "$optional" = 1 ] ||
			rules_error "Unmatched pattern specified: $pattern"
	done
}

parse_rules()
{
	[ -s "$workdir/rules" ] || return 0

	echo >>"$workdir/rules"

	exclude_pattern_list=
	lineno=0

	local cmd options
	while read -r cmd options; do
		lineno="$((lineno+1))"
		if [ "$cmd" = 'exclude:' ]; then
			[ -z "$(printf %s "$options" |tr -d '[:alnum:]_.?*-/')" ] ||
				rules_error "Invalid exclude pattern specified: $options"
			exclude_pattern_list="$exclude_pattern_list $options"
		fi
	done <"$workdir/rules"

	lineno=0
	while read -r cmd options; do
		lineno="$((lineno+1))"
		local optional=0
		case "$cmd" in
			""|\#*)
				continue
				;;
			*\?:)
				cmd="${cmd%\?:}"
				optional=1
				;;
			*:)
				cmd="${cmd%:}"
				optional=0
				;;
			*)
				rules_info "Unrecognized rule ignored: $cmd"
				continue
				;;
		esac
		case "$cmd" in
			spec|exclude|tags)
				continue
				;;
			tar|tar.gz|tar.bz2)
				make_archive 'tar' "$optional" "$cmd" $options ||
					rules_error 'Failed to make archive'
				;;
			zip)
				make_archive 'zip' "$optional" "$cmd" $options ||
					rules_error 'Failed to make archive'
				;;
			diff|diff.gz|diff.bz2)
				make_difference "$optional" "$cmd" $options ||
					rules_error 'Failed to make diff'
				;;
			copy|gzip|bzip2)
				copy_by_pattern "$optional" "$cmd" $options ||
					rules_error 'Failed to copy by pattern'
				;;
			*)
				rules_info "Unrecognized directive ignored: $cmd"
				continue
				;;
		esac
	done <"$workdir/rules"
	lineno=
}

TEMP=`getopt -n $PROG -o "$gear_short_options" -l "$gear_long_options" -- "$@"` ||
	show_usage
eval set -- "$TEMP"

hasher=
update_spec=
rpmbuild=
command=
command_helper='gear-command-tar'
outdir=
describe=
do_commit=
tar_compress=--gzip
main_tree_id=HEAD
while :; do
	case "$1" in
		--) shift; break
			;;
		--no-compress) tar_compress=
			;;
		--commit) do_commit=1
			[ "$main_tree_id" = HEAD ] ||
				show_usage 'Options --commit and --tree-ish are mutually exclusive.'
			;;
		--bzip2) tar_compress=--bzip2
			;;
		--gzip) tar_compress=--gzip
			;;
		--command) command=1; command_helper=
			;;
		--hasher) hasher=1
			[ -z "$outdir$rpmbuild$describe$command" ] ||
				show_usage 'Options --hasher, --rpmbuild, --export-dir, --command and --describe are mutually exclusive.'
			command_helper='gear-command-hasher'
			;;
		--rpmbuild) rpmbuild=1
			[ -z "$hasher$outdir$describe$command" ] ||
				show_usage 'Options --hasher, --rpmbuild, --export-dir, --command and --describe are mutually exclusive.'
			command_helper='gear-command-rpmbuild'
			;;
		--update-spec) update_spec=1
			;;
		--export-dir)
			outdir="$(opt_check_dir "$1" "$2")"
			shift
			[ -z "$hasher$rpmbuild$describe$command" ] ||
				show_usage 'Options --hasher, --rpmbuild, --export-dir, --command and --describe are mutually exclusive.'
			;;
		--describe) describe=1
			[ -z "$hasher$outdir$rpmbuild$command" ] ||
				show_usage 'Options --hasher, --rpmbuild, --export-dir, --command and --describe are mutually exclusive.'
			;;
		-r|--rules) shift; rules="$1"
			;;
		-t|--tree-ish) shift; main_tree_id="$1"
			[ -z "$do_commit" -o "$main_tree_id" = HEAD ] ||
				show_usage 'Options --commit and --tree-ish are mutually exclusive.'
			;;
		-h|--help) show_help
			;;
		-q|--quiet) quiet=-q; verbose=
			;;
		-v|--verbose) verbose=-v; quiet=
			;;
		-V|--version) print_version
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

out_file=
if [ -n "$hasher$rpmbuild$command" ]; then
	# At least one argument, please.
	[ "$#" -ge 1 ] ||
		show_usage 'Not enough arguments.'
elif [ -n "$outdir$describe" ]; then
	[ "$#" -eq 0 ] ||
		show_usage 'Too many arguments.'
else
	# Exactly one argument, please.
	[ "$#" -ge 1 ] ||
		show_usage 'Not enough arguments.'
	[ "$#" -eq 1 ] ||
		show_usage 'Too many arguments.'
	out_file="$1"
	shift
fi

# Save git directory for future use.
git_dir="$(git rev-parse --git-dir)"
git_dir="$(readlink -ev -- "$git_dir")"

# Change to toplevel directory.
chdir_to_toplevel

# Check given tree-ish.
main_commit_id="${main_tree_id%%:*}"
main_commit_sha1="$(get_commit_sha1 "$main_commit_id")" ||
	fatal "Invalid commit \"$main_commit_id\""
main_tree_sha1="$(get_object_sha1 "$main_tree_id")" ||
	fatal "Invalid tree \"$main_tree_id\""
git cat-file -e "$main_tree_sha1^{tree}" ||
	fatal "Invalid tree \"$main_tree_id\""

if [ -n "$update_spec" ]; then
	[ -n "$rpmbuild$command" ] ||
		fatal 'Unable to update specfile without appropriate command.'
fi

tmpdir="$(mktemp -dt "$PROG.XXXXXXXX")"
trap exit_handler HUP PIPE INT QUIT TERM EXIT
workdir="$tmpdir/work"
mkdir "$workdir"
if [ -z "$outdir" ]; then
	outdir="$tmpdir/out"
	mkdir $verbose "$outdir"
fi

if [ -n "$do_commit" ]; then
	if git commit -a -m "Temporary commit by $PROG."; then
		verbose 'Temporarily committed local changes.'
		tmp_commit_id="$(get_object_sha1 HEAD)" ||
			fatal 'Failed to parse HEAD after temporary commit.'
	fi
fi

find_specfile

if [ -n "$describe" ]; then
	printf '%s %s %s\n' "$pkg_name" "$pkg_version" "$pkg_release"
	exit 0
fi

# Create a temporary object directory for extracting stored tags.
orig_object_dir="${GIT_OBJECT_DIRECTORY-"$git_dir/objects"}"
mkdir -p "$tmpdir/objects/info"
printf %s\\n "$orig_object_dir" >"$tmpdir/objects/info/alternates"
GIT_OBJECT_DIRECTORY="$tmpdir/objects"
export GIT_OBJECT_DIRECTORY

find_tags_in_tree
parse_rules

install -pm644 "$workdir/specfile" "$outdir/${specfile##*/}"
verbose "Extracted specfile: ${specfile##*/}"

if [ -n "$update_spec" ]; then
	[ -f "$specfile" ] ||
		fatal "Unable to update specfile: file $specfile not available."
	cmp -s "$specfile" "$workdir/specfile" ||
		fatal "Unable to update specfile: file $specfile differs from original specfile."
fi

gear_commit_id="${tmp_commit_id:-$main_commit_id}"
gear_commit_id="$(get_object_sha1 "$gear_commit_id")" ||
	fatal 'Failed to parse commit.'
export gear_commit_id

gear_pkg_name="$pkg_name"
gear_pkg_version="$pkg_version"
gear_pkg_release="$pkg_release"
export gear_pkg_name gear_pkg_version gear_pkg_release

gear_outdir="$outdir"
gear_outfile="${out_file:-$workdir/pkg.tar}"
gear_specfile="$specfile"
gear_tmpdir="$tmpdir"
gear_workdir="$workdir"
export gear_outdir gear_outfile gear_specfile gear_tmpdir gear_workdir

gear_rules="$rules"
gear_tar_compress="$tar_compress"
gear_update_spec="$update_spec"
gear_quiet="$quiet"
gear_verbose="$verbose"
export gear_rules gear_tar_compress gear_update_spec gear_quiet gear_verbose

run_command $command_helper "$@"
