#!/bin/sh -efu
#
# Copyright (C) 2021  Alexey Gladkov <legion@altlinux.org>
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#

. gear-utils-sh-functions

tmpdir=
cleanup_handler()
{
	[ -z "$tmpdir" ] || rm -rf -- "$tmpdir"
}

print_version()
{
	cat <<EOF
$PROG version $PROG_VERSION
Written by Alexey Gladkov <legion@altlinux.org>

Copyright (C) 2021  Alexey Gladkov <legion@altlinux.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
	exit
}

show_help()
{
	cat <<EOF
Regular git-submodule cannot be used in gear since submodule objects are
not stored in the object database, there is just a reference to a hash
in another repository.  Therefore, cloning such a repository does not
guarantee that all necessary objects are available in the clone.

gear-store-submodules can be used to save and restore the necessary
objects as bundles.  This utility saves all submodules recursively.

Usage: $PROG [options] [status]
or:    $PROG [options] save
or:    $PROG [options] restore

Options:
  -v, --verbose             print a message for each action;
  -q, --quiet               do not print a message for each action;
  -V, --version             print program version and exit;
  -h, --help                show this text and exit.

Report bugs to https://bugzilla.altlinux.org/

EOF
	exit
}

TEMP=`getopt -n "$PROG" -o $getopt_common_opts -l $getopt_common_longopts -- "$@"` ||
	show_usage
eval set -- "$TEMP"

quiet=-q
verbose=
while :; do
	case "$1" in
		--) shift; break
			;;
		-q|--quiet) verbose='' quiet=-q
			;;
		-v|--verbose) verbose=v quiet=''
			;;
		-h|--help) show_help
			;;
		-V|--version) print_version
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

# Save git directory for future use.
git_dir="$(git rev-parse --git-dir)"
git_dir="$(readlink -ev -- "$git_dir")"

# Change to toplevel directory.
chdir_to_toplevel

module_dir='.gear/submodules'

mkdir -p -- "$module_dir"

install_cleanup_handler cleanup_handler
tmpdir="$(mktemp -d "$module_dir/$PROG.XXXXXXXX")"

save_submodules()
{
	local sm_hash sm_path

	if git submodule status --recursive | grep -qs '^[+-]'; then
		fatal 'some submodules are not synchronized'
	fi

	git submodule --quiet foreach --recursive 'echo $sha1 $displaypath' |
	while read -r sm_hash sm_path; do {
		verbose "Bundling up submodule $sm_path ..."

		local bundle
		bundle="$(printf '%s' "$sm_path" |git hash-object --stdin)"

		local sm_git_dir
		sm_git_dir="$(git --git-dir="$sm_path/.git" rev-parse --git-dir)"

		git --git-dir="$sm_git_dir" \
			bundle create $quiet "$tmpdir/$bundle" HEAD

		local differ=
		if [ ! -s "$module_dir/$bundle" ]; then
			[ -n "$quiet" ] ||
				message "Adding $sm_path ..."
			differ=1
		elif ! cmp -s -- "$tmpdir/$bundle" "$module_dir/$bundle"; then
			[ -n "$quiet" ] ||
				message "Updating $sm_path ..."
			differ=1
		fi

		if [ -n "$differ" ]; then
			mv -f -- "$tmpdir/$bundle" "$module_dir/$bundle"
			git update-index --add -- "$module_dir/$bundle"
			printf '%s %s\n' "$bundle" "$sm_path" >> "$tmpdir/differ"
		else
			[ -n "$quiet" ] ||
				message "Skipped unchanged $sm_path ..."
			rm -f -- "$tmpdir/$bundle"
		fi

		printf '%s %s %s %s\n' \
			"$bundle" "$sm_hash" "$sm_path" "${sm_git_dir#$git_dir/}"
	} < /dev/null; done > "$tmpdir/list"

	local list_file
	list_file="$module_dir/list"

	if [ -s "$list_file" ]; then
		local cur_bundle cur_hash cur_path cur_git_dir
		local new_bundle new_hash new_path new_git_dir

		while read -r cur_bundle cur_hash cur_path cur_git_dir; do {
			while read -r new_bundle new_hash new_path new_git_dir; do
				[ "$cur_bundle" != "$new_bundle" ] ||
					continue 2
			done < "$tmpdir/list"

			[ -n "$quiet" ] ||
				message "Removing $cur_path ..."

			git rm $quiet -f -- "$module_dir/$cur_bundle"
			printf '%s %s\n' "$cur_bundle" "$cur_path" >> "$tmpdir/differ"
		} < /dev/null; done < "$list_file"
	fi

	[ -s "$tmpdir/differ" ] ||
		return 0

	[ -n "$quiet" ] ||
		message "Updating $list_file ..."
	mv -f -- "$tmpdir/list" "$list_file"
	git update-index --add -- "$list_file"
}

restore_submodules()
{
	local list_file
	list_file="$module_dir/list"
	if [ ! -s "$list_file" ]; then
		[ -n "$quiet" ] ||
			message "$list_file not found"
		return 0
	fi

	local bundle sm_hash sm_path sm_git_dir
	while read -r bundle sm_hash sm_path sm_git_dir; do {
		[ -n "$quiet" ] ||
			message "Unbundling $sm_path from $bundle ..."

		if [ -d "$sm_git_dir" ]; then
			git --git-dir="$git_dir/$sm_git_dir" fetch $quiet \
				--no-recurse-submodules \
				"$module_dir/$bundle" HEAD
			git --git-dir="$git_dir/$sm_git_dir" update-ref \
				HEAD "$sm_hash"
		else
			git clone $quiet \
				--bare \
				--no-remote-submodules \
				-- "$module_dir/$bundle" "$git_dir/$sm_git_dir"
			git --git-dir="$git_dir/$sm_git_dir" config \
				core.bare false
		fi
	} < /dev/null; done < "$list_file"

	[ -n "$quiet" ] ||
		message 'Updating registered submodules ...'
	git submodule update $quiet --init --recursive --no-fetch --checkout
}

status_submodules()
{
	local list_file
	list_file="$module_dir/list"
	[ -s "$list_file" ] ||
		fatal "index file not found: $list_file"

	if git submodule status --recursive | grep -qs '^[+-]'; then
		fatal 'some submodules are not synchronized'
	fi

	git submodule --quiet foreach --recursive \
		'echo `git rev-parse HEAD` $displaypath' > "$tmpdir/modules"

	>> "$tmpdir/ok"
	>> "$tmpdir/new"
	>> "$tmpdir/modified"

	local bundle hash path sm_hash sm_path dummy status
	while read -r sm_hash sm_path; do {
		status=
		while read -r bundle hash path dummy; do
			if [ "$path" = "$sm_path" ]; then
				status='ok'
				[ "$hash" = "$sm_hash" ] ||
					status='modified'
				break
			fi
		done < "$list_file"

		[ -n "$status" ] ||
			status='new'

		printf '%s\n' "$sm_path" >> "$tmpdir/$status"
	} < /dev/null; done < "$tmpdir/modules"

	while read -r bundle hash path dummy; do
		while read -r sm_hash sm_path; do
			[ "$path" != "$sm_path" ] ||
				continue 2
		done < "$tmpdir/modules"
		printf '%s\n' "$path"
	done < "$list_file" > "$tmpdir/obsolete"

	[ -s "$tmpdir/new" ] ||
	[ -s "$tmpdir/modified" ] ||
	[ -s "$tmpdir/obsolete" ] || {
		if [ -n "$verbose" ]; then
			printf 'List of modules:\n'
			sed -e 's/^/  ok: &/' "$tmpdir/ok"
			printf '\n'
		fi
		echo 'All submodules are synchronized.'
		return
	}

	printf 'Submodules changes:\n'
	sed -e 's/^/  new:      &/' "$tmpdir/new"
	sed -e 's/^/  obsolete: &/' "$tmpdir/obsolete"
	sed -e 's/^/  modified: &/' "$tmpdir/modified"
	printf '\n'
	printf 'Use "%s save" to sync all modules.\n' "$PROG"
}

case "${1-}" in
	save)
		save_submodules
		;;
	restore)
		restore_submodules
		;;
	''|status)
		status_submodules
		;;
	*)
		fatal "unknown subcommand: $action"
esac
