#!/bin/sh -efu
#
# Copyright (C) 2007  Alexey Gladkov <legion@altlinux.org>
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#
# Rules:
# directive: args
#
# directive  := ( merge | gendiff )
# args       := ( -strategy | -squash | -message | -unified | -name )
# -name      := <file>
# -message   := <text>
# -unified   := <number>
# -strategy  := <git merge strategy>
# -squash    := NONE
#
# <git merge strategy> - Use the given merge strategy. See man git-merge(1).
#

. gear-sh-functions

show_help() {
	cat <<EOF
$PROG - Merge branches in the package repository

Usage: $PROG [Options]

Options:

  -a, --add              add new patches in git repository;
  -r, --rules=FILENAME   name of file with rules, default is .gear/merge;
  -v,--verbose           print a message for each action;
  -V,--version           print program version and exit;
  -h,--help              show this text and exit.

Report bugs to http://bugs.altlinux.ru/

EOF
	exit
}

print_version() {
	cat <<EOF
$PROG version $PROG_VERSION
Written by Alexey Gladkov <legion@altlinux.org>

Copyright (C) 2007  Alexey Gladkov <legion@altlinux.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
	exit
}

checkout_current=
current_branch=
workdir=
exit_handler() {
	local rc=$?
	trap - EXIT
	[ -z "$workdir" ] ||
		rm -rf -- "$workdir"

	if [ "$rc" -eq 0 -a -n "$checkout_current" ]; then
		git checkout "$current_branch"
	fi
	exit $rc
}

main_tree_id='HEAD'
rules=
find_merge_rules() {
	: >"$workdir/rules"
	if [ -n "$(git ls-tree "$main_tree_id" "$rules")" ]; then
		cat_blob "$main_tree_id" "$rules" >"$workdir/rules"
	fi
}

validate_rule() {
	local cmd src dst
	cmd="$1"; shift
	src="$1"; shift
	dst="$1"; shift

	for b in "$src" "$dst"; do
		[ -n "$(git ls-remote -h . "refs/heads/$b")" ] ||
			fatal "$b: branch not found."
	done

	[ "$cmd" != 'gendiff' -o -n "$name" ] ||
		rules_error "patch name not defined. Use '-name' option."
}

parse_options() {
	name= message= squash= strategy= unified=
	[ "$#" -gt 0 ] || return 0

	local TEMP
	TEMP=`getopt -a -o n:,m:,u:,s:,S -l name:,message:,unified:,strategy:,squash -- "$@" 2>/dev/null` ||
		fatal "Unable to parse options"

	eval set -- "$TEMP"
	while :; do
		case "${1-}" in
			-n|--name)     shift; name="$1" ;;
			-m|--message)  shift; message="$1" ;;
			-u|--unified)  shift; unified="$1" ;;
			-s|--strategy) shift; strategy="$1" ;;
			-S|--squash)   shift; squash='--sq' ;;
			--)            shift; break ;;
		esac
		shift
	done
	[ "$#" -eq 0 ] ||
		rules_error "unknown option: $*"
}

parse_rules() {
	local parser_func="${1-}"
	local cmd options src dst lineno=0

	echo >>"$workdir/rules"
	while read -r cmd options; do
		lineno=$(($lineno+1))
		eval set -- "$options"

		cmd="${cmd%:}"
		case "$cmd" in
			merge)
				[ "$#" -ge 1 ] ||
					rules_error 'expected syntax: <command> <branch-to-merge> [<options>]'
				src="$current_branch"
				dst="$1"; shift
				;;
			gendiff)
				[ "$#" -ge 2 ] ||
					rules_error 'expected syntax: <command> <src-branch> <dst-branch> [<options>]'
				src="$1"; shift
				dst="$1"; shift
				;;
			''|'#'*) continue ;;
			*) rules_error 'unknown command.' ;;
		esac

		parse_options "$@"

		if [ -n "$parser_func" ]; then
			$parser_func "$cmd" "$src" "$dst"
			continue
		fi

		branch_$cmd "$src" "$dst"

	done < "$workdir/rules"
}

is_already_merged() {
	[ -z "$(git-rev-list --max-count=1 "$1".."$2")" ] || return 1
}

branch_merge() {
	local src dst
	src="$1"; shift
	dst="$1"; shift

	if is_already_merged "$src" "$dst"; then
		verbose "No new commits in branch '$src'"
		return 0
	fi

	git merge \
		${squash:-} \
		${strategy:+-s "$strategy"} \
		${message:+-m "$message"} \
		"refs/heads/$dst" ||
		fatal "Unable to merge '$dst' automatically"
}

new_files=
add_new_files=
branch_gendiff() {
	local dir

	local src dst
	src="$1"; shift
	dst="$1"; shift

	git checkout "$dst"
	merge_branch "$dst" "$src"

	dir="${name%/*}"
	[ "$dir" = "$name" -o -d "$dir" ] ||
		mkdir -p -- "$dir"

	{ [ -z "$message" ] || printf '%s\n\n' "$message"; } > "$name"

	git diff \
		-p \
		--no-color \
		--ignore-space-change \
		${unified:+--unified="$unified"} \
		"refs/heads/$src".."refs/heads/$dst" >> "$name" ||
		fatal "Unable to generate diff between '$src' and '$dst'"

	[ -z "$add_new_files" ] ||
		new_files="$new_files $name"

	checkout_current=1
}

TEMP=`getopt -n $PROG -o a,r:,V,v,h -l add,rules:,version,verbose,help -- "$@"` || show_usage
eval set -- "$TEMP"

rules='.gear/merge'
while :; do
	case "$1" in
		-a|--add) add_new_files=1
			;;
		-r|--rules) shift; rules="$1"
			;;
		-v|--verbose) verbose=-v
			;;
		-V|--version) print_version
			;;
		-h|--help) show_help
			;;
		--) shift; break
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

# Save git directory for future use.
git_dir="$(git rev-parse --git-dir)"
git_dir="$(readlink -ev "$git_dir")"

# Change to toplevel directory.
chdir_to_toplevel

out="$(git diff-index --cached --name-only HEAD)"
[ -z "$out" ] ||
	fatal "Changed files found in the index."

out="$(git diff --name-only &&
       git ls-files --directory --others --exclude-per-directory=.gitignore)"
[ -z "$out" ] ||
	fatal "Untracked or modified files found."

current_branch="$(git-symbolic-ref "$main_tree_id")"

[ -z "${current_branch%%refs/heads/*}" ] ||
	fatal "$main_tree_id: not a branch."

current_branch="${current_branch#refs/heads/}"

trap exit_handler HUP PIPE INT QUIT TERM EXIT
workdir="$(mktemp -dt "$PROG.XXXXXXXX")"

#find_merge_rules
cp -f "$rules" "$workdir/rules"

if [ ! -s "$workdir/rules" ]; then
	msg_info "No rules found."
	show_usage
	exit 0
fi

parse_rules 'validate_rule'
parse_rules

if [ -n "$add_new_files" -a -n "$new_files" ]; then
	git checkout "$current_branch"
	git add $new_files
	checkout_current=
fi
